import tkinter as tk
from tkinter import scrolledtext, filedialog, messagebox, ttk
import threading
import os
import subprocess
import sys
import queue
import json
import webbrowser
import tempfile
from datetime import datetime
from typing import Optional
from generate_podcast import validate_speakers, update_elevenlabs_quota
from create_demo import create_html_demo

# --- Versioning ---
# This file is automatically generated by setuptools-scm
try:
    from _version import __version__  # type: ignore
except Exception:
    # Fallback développement: quand _version.py n'est pas encore généré
    __version__ = "0.0.0-dev"


AVAILABLE_VOICES = {
    "Zephyr": "Bright",
    "Puck": "Upbeat",
    "Charon": "Informative",
    "Kore": "Firm",
    "Fenrir": "Excitable",
    "Leda": "Youthful",
    "Orus": "Firm",
    "Aoede": "Breezy",
    "Callirrhoe": "Easy-going",
    "Autonoe": "Bright",
    "Enceladus": "Breathy",
    "Iapetus": "Clear",
    "Umbriel": "Easy-going",
    "Algieba": "Smooth",
    "Despina": "Smooth",
    "Erinome": "Clear",
    "Algenib": "Gravelly",
    "Rasalgethi": "Informative",
    "Laomedeia": "Upbeat",
    "Achernar": "Soft",
    "Alnilam": "Firm",
    "Schedar": "Even",
    "Gacrux": "Mature",
    "Pulcherrima": "Forward",
    "Achird": "Friendly",
    "Zubenelgenubi": "Casual",
    "Vindemiatrix": "Gentle",
    "Sadachbia": "Lively",
    "Sadaltager": "Knowledgeable",
    "Sulafat": "Warm"
}

SERVICE_CONFIG = {
    "elevenlabs": {
        "title": "ElevenLabs API Key",
        "account": "elevenlabs_api_key",
        "url": "https://try.elevenlabs.io/zobct2wsp98z"
    },
    "gemini": {
        "title": "Gemini API Key",
        "account": "gemini_api_key",
        "url": "https://aistudio.google.com/app/apikey"
    }
}


def get_app_version() -> str:
    """Gets the application version from the _version.py file."""
    return __version__


def get_asset_path(filename: str) -> Optional[str]:
    """
    Gets the absolute path to an asset, handling running from source and from
    a PyInstaller bundle.
    """
    if getattr(sys, 'frozen', False):
        # The application is frozen (packaged with PyInstaller)
        bundle_dir = sys._MEIPASS
    else:
        # The application is running in a normal Python environment
        bundle_dir = os.path.dirname(os.path.abspath(__file__))

    path = os.path.join(bundle_dir, filename)
    return path if os.path.exists(path) else None


class PodcastGeneratorApp:
    DEFAULT_SPEAKER_SETTINGS = {"John": "Schedar - Even", "Samantha": "Zephyr - Bright"}
    DEFAULT_APP_SETTINGS = {
        "tts_provider": "elevenlabs",
        "speaker_voices": {"John": "Schedar - Even", "Samantha": "Zephyr - Bright"},
        "speaker_voices_elevenlabs": {
            "John": {"id": "TX3LPaxmHKxFdv7VOQHJ", "display_name": "Liam - Male, Young, american"},
            "Samantha": {"id": "cgSgspJ2msm6clMCkdW9", "display_name": "Jessica - Female, Young, american"}
        },
        "elevenlabs_quota_cache": None
    }

    def __init__(self, root: tk.Tk, generate_func, logger, api_key: str, default_script: str = ""):
        self.root = root
        self.root.title(f"Podcast Generator v{get_app_version()}")
        self.root.geometry("960x700")
        # --- Application Icon ---
        icon_path = get_asset_path("podcast.png")
        if icon_path:
            try:
                img = tk.PhotoImage(file=icon_path)
                self.root.tk.call('wm', 'iconphoto', self.root._w, img)
            except tk.TclError:
                # In case of format error, continue without icon
                pass

        # --- Define configuration paths ---
        from generate_podcast import get_app_data_dir, find_ffplay_path  # Local import
        self.app_data_dir = get_app_data_dir()
        self.settings_filepath = os.path.join(self.app_data_dir, "settings.json")

        self.generate_func = generate_func
        self.logger = logger
        self.api_key = api_key
        self.log_queue = queue.Queue()
        self.playback_obj = None  # To keep a reference to the playback process
        self.sample_playback_obj = None # For voice sample playback
        self._active_play_button: Optional[tk.Button] = None
        self.sample_poll_id = None # For polling playback status
        self.last_generated_filepath = None
        self.last_generated_script = None # To store script for demo generation
        self.ffplay_path = find_ffplay_path()
        self.is_mfa_available = self.check_mfa_availability()
        self.elevenlabs_quota_text = None # New state variable

        self.app_settings = self.load_settings()
        self.provider_var = tk.StringVar(value=self.app_settings.get("tts_provider", "elevenlabs").lower())

        self._setup_menu()
        self._setup_widgets(default_script)

        # Provider sélectionné
        self.provider_var = tk.StringVar(value=self.app_settings.get("tts_provider", "elevenlabs").lower())
        if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

        # Cache des voix ElevenLabs préchargées
        self.elevenlabs_voices_cache = []

        self.poll_log_queue()

        # Update UI states after all widgets are created
        self.update_provider_menu_state()
        self.update_voice_settings_enabled()

        # Schedule initial quota fetch and theme watcher
        if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
            self._schedule_provider_label_refresh(delay_ms=2000, retries=5)
        self._start_theme_watcher()

        self.logger.info("Main interface initialized.")

    def check_mfa_availability(self) -> bool:
        """Checks if MFA is installed and runnable, without showing errors to the user."""
        # Using 'mfa' directly relies on it being in the system's PATH.
        # This is the correct approach for an external dependency and avoids
        # the infinite loop issue with frozen apps, where sys.executable
        # would point to the app bundle itself.
        mfa_base_command = ["mfa"]
        try:
            # We only care about the return code. Using DEVNULL for output is efficient.
            # The command is 'version' for MFA v3.x
            subprocess.run(
                mfa_base_command + ["version"],
                check=True,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            self.logger.info("MFA installation found and verified. Demo generation is enabled.")
            return True
        except (subprocess.CalledProcessError, FileNotFoundError, NotADirectoryError):
            self.logger.warning("MFA not found or installation is broken. Demo generation will be disabled.")
            return False


    def _setup_menu(self):
        """Sets up the main application menu bar."""
        # --- Menu Bar (Platform-specific) ---
        self.menubar = tk.Menu(self.root)
        self.root.config(menu=self.menubar)

        if sys.platform == "darwin":  # macOS
            try:
                # Create the special "app" menu. This can fail on non-native Tcl/Tk.
                app_menu = tk.Menu(self.menubar, name='apple', tearoff=0)
                self.menubar.add_cascade(label="Podcast Generator", menu=app_menu)

                app_menu.add_command(label=f"About Podcast Generator", command=self.show_about_window)
                app_menu.add_separator()
                app_menu.add_command(label="Voice settings...", command=self.open_settings_window,
                                     accelerator="Command+,")
                app_menu.add_separator()
                # Add standard macOS services for a native feel
                app_menu.add_command(label="Services", role="services")
                app_menu.add_separator()
                app_menu.add_command(label="Hide Podcast Generator", accelerator="Command+H", role="hide")
                app_menu.add_command(label="Hide Others", accelerator="Command+Option+H", role="hideothers")
                app_menu.add_command(label="Show All", role="unhide")
                app_menu.add_separator()
                app_menu.add_command(label="Quit Podcast Generator", accelerator="Command+Q", role="quit")
            except tk.TclError:
                # Fallback for older Tcl/Tk. Clear any partially created menu.
                self.menubar.delete(0, 'end')
                # (Le menu Settings sera créé plus bas, commun à toutes les plateformes)

        # Création du menu Settings (commun à toutes les plateformes)
        self.settings_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Settings", menu=self.settings_menu)

        # Sous-menu TTS provider (n’apparaît que si 2 clés sont présentes)

        self.tts_submenu = None
        self.rebuild_tts_provider_menu()

        # Quit (pour Windows/Linux; sur macOS l'app menu expose déjà Quit)
        if sys.platform != "darwin":
            self.settings_menu.add_separator()
            self.settings_menu.add_command(label="Quit", command=self.root.quit)

        # --- Actions Menu ---
        self.actions_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Actions", menu=self.actions_menu)
        self.actions_menu.add_command(label="Generate HTML Demo...",
                                      command=self.start_demo_generation_thread,
                                      state='disabled')

        # Help Menu (common to all platforms)
        help_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Documentation (Github)...", command=self.open_documentation)
        help_menu.add_command(label="About...", command=self.show_about_window)

    def _setup_widgets(self, default_script: str):
        """Sets up the main UI widgets like text areas and buttons."""
        # --- Main Frame ---
        main_frame = tk.Frame(self.root, padx=10, pady=10)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- TTS Provider Status Bar ---
        status_frame = tk.Frame(main_frame, relief=tk.SUNKEN, bd=1)
        status_frame.pack(fill=tk.X, pady=(0, 5))

        current_provider = self.app_settings.get("tts_provider", "elevenlabs").title()
        # Couleur adaptative selon le mode sombre macOS
        self._is_dark_mode = self._is_system_dark_mode()
        text_color = "white" if self._is_dark_mode else "blue"
        self.provider_label = tk.Label(status_frame, text=f"TTS Provider: {current_provider}", font=('Helvetica', 9),
                                       fg=text_color)
        self.provider_label.pack(side=tk.LEFT, padx=5, pady=2)
        # Déclenche le rafraîchissement du quota immédiatement si ElevenLabs est actif
        if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
            self._load_cached_quota()
            self.update_elevenlabs_quota_in_status()
        # Lance le watcher de thème (actualise la couleur s'il y a bascule sombre/clair)
        self._start_theme_watcher()

        # --- Script Text Area ---
        script_frame = tk.LabelFrame(main_frame, text="Script to read", padx=5, pady=5)
        script_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))


        self.script_text = scrolledtext.ScrolledText(script_frame, wrap=tk.WORD, height=15, width=80)
        self.script_text.pack(fill=tk.BOTH, expand=True)
        self.script_text.insert(tk.END, default_script)

        # --- Log/Status Area ---
        log_frame = tk.LabelFrame(main_frame, text="Generation status", padx=5, pady=5)
        log_frame.pack(fill=tk.BOTH, expand=True)

        self.log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, height=10, state='disabled')
        self.log_text.pack(fill=tk.BOTH, expand=True)

        # --- Progress Bar (initially hidden) ---
        self.progress_bar = ttk.Progressbar(main_frame, mode='indeterminate')

        # --- Button Frame ---
        self.button_frame = tk.Frame(main_frame)
        self.button_frame.pack(fill=tk.X, pady=(10, 0))

        # Define a common width for visual consistency
        common_button_width = 22

        # --- Left-aligned buttons ---
        self.load_button = tk.Button(self.button_frame, text="Load a script (.txt)", command=self.load_script_from_file,
                                     width=common_button_width)
        self.load_button.pack(side=tk.LEFT, padx=(0, 5))

        self.generate_button = tk.Button(self.button_frame, text="Start generation",
                                         command=self.start_generation_thread, width=common_button_width)
        self.generate_button.pack(side=tk.LEFT)

        # --- Right-aligned buttons (packed in reverse order for correct display) ---
        self.show_button = tk.Button(self.button_frame, text="Open file location", command=self.open_file_location,
                                     state='disabled', width=common_button_width)
        self.show_button.pack(side=tk.RIGHT, padx=(5, 0))

        self.play_button = tk.Button(self.button_frame, text="▶️ Play", command=self.play_last_generated_file,
                                     state='disabled', width=common_button_width)
        self.play_button.pack(side=tk.RIGHT)

    def _load_cached_quota(self):
        """Loads and displays the cached quota if available."""
        cached = self.app_settings.get("elevenlabs_quota_cache") or {}
        cached_text = cached.get("text")
        if cached_text:
            self.elevenlabs_quota_text = cached_text
            self._update_provider_label()

    def _is_system_dark_mode(self) -> bool:
        """Retourne True si le système (macOS ou Windows) est en mode sombre."""
        try:
            if sys.platform == "darwin":
                # AppleInterfaceStyle existe seulement en mode sombre
                proc = subprocess.run(
                    ["defaults", "read", "-g", "AppleInterfaceStyle"],
                    capture_output=True, text=True
                )
                return proc.returncode == 0 and proc.stdout.strip().lower() == "dark"

            if sys.platform == "win32":
                import winreg
                key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r'Software\Microsoft\Windows\CurrentVersion\Themes\Personalize')
                value, _ = winreg.QueryValueEx(key, 'AppsUseLightTheme')
                winreg.CloseKey(key)
                return value == 0
        except Exception:
            # En cas d'erreur (ex: clé de registre absente, commande non trouvée), on suppose le mode clair.
            return False
        return False  # Pour les autres OS (Linux, etc.)

    def _apply_provider_label_theme(self):
        """Applique la bonne couleur au provider_label selon le mode sombre."""
        if not hasattr(self, 'provider_label'):
            return
        # Blanc en mode sombre, bleu sinon
        self.provider_label.config(fg=("white" if self._is_dark_mode else "blue"))

    def _start_theme_watcher(self, interval_ms: int = 2000):
        """Surveille le mode sombre (macOS/Windows) et met à jour la couleur du provider_label si l'état change."""
        def _tick():
            try:
                current = self._is_system_dark_mode()
                if current != self._is_dark_mode:
                    self._is_dark_mode = current
                    self._apply_provider_label_theme()
            finally:
                # Replanifie la prochaine vérification
                if self.root and self.root.winfo_exists():
                    self.root.after(interval_ms, _tick)
        # Premier tick après interval_ms
        if self.root and self.root.winfo_exists():
            self.root.after(interval_ms, _tick)


    def on_provider_selected(self):
        """Handles selection from the TTS Provider radio button menu."""
        new_provider = self.provider_var.get()
        # Prevent running the switch logic if the selection hasn't actually changed.
        # This can happen if the user cancels the API key dialog.
        if new_provider != self.app_settings.get("tts_provider"):
            self.switch_tts_provider(new_provider)

    def switch_tts_provider(self, provider: str):
        """Switch TTS provider, update settings, and fetch the correct API key."""
        if provider not in ["gemini", "elevenlabs"]:
            return

        from generate_podcast import get_api_key  # Local import is safe
        provider_title = "ElevenLabs v3" if provider == "elevenlabs" else provider.title()

        # Attempt to get the new API key from storage.
        # get_api_key will now return None immediately if the key is not in storage and we are in GUI mode.
        new_api_key = get_api_key(self.log_status, self.logger, parent_window=self.root, service=provider)

        # If the key is not found in storage, we need to ask the user.
        if not new_api_key:
            self.log_status(f"API key for {provider_title} not found in storage.")

            if messagebox.askyesno(
                    "API Key Required",
                    f"The API key for {provider_title} is not configured.\n\n"
                    f"Would you like to set it now?",
                    parent=self.root
            ):
                # Open the key management window and wait for it to close.
                keys_window = self.open_api_keys_window()
                self.root.wait_window(keys_window)

                # After the window is closed, try to get the key again from storage.
                new_api_key = get_api_key(self.log_status, self.logger, parent_window=self.root, service=provider)

        # If the key is still not available (user cancelled), abort the switch.
        if not new_api_key:
            self.log_status(f"API key acquisition for {provider_title} failed. Provider switch cancelled.")
            # Revert the radio button to the previous valid setting
            self.provider_var.set(self.app_settings.get("tts_provider", "elevenlabs"))
            return # Do not show a warning, as the user has already interacted with a dialog.

        # If successful, update the API key in memory and in the settings.
        self.api_key = new_api_key
        self.app_settings["tts_provider"] = provider
        self.save_settings(self.app_settings)

        # Update UI to reflect the change
        self._update_provider_label()  # Update the label to its base state
        self.log_status(f"Successfully switched TTS provider to {provider_title}.")
        if provider == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

    def update_provider_menu_state(self):
        """
        Met à jour la disponibilité du sous-menu TTS provider en fonction des clés API.
        Le sous-menu n’apparaît que si les 2 clés sont configurées.
        """
        import keyring

        gemini_key_exists = bool(keyring.get_password("PodcastGenerator", "gemini_api_key"))
        elevenlabs_key_exists = bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))

        # (Re)construit le sous-menu dynamiquement
        self.rebuild_tts_provider_menu()

        # Cas limites: si la clé du provider courant a disparu, basculer vers l’autre si possible
        current_provider = self.provider_var.get()
        if current_provider == "gemini" and not gemini_key_exists and elevenlabs_key_exists:
            self.log_status("Gemini API key not found. Switching to ElevenLabs.")
            self.provider_var.set("elevenlabs")
            self.on_provider_selected()
        elif current_provider == "elevenlabs" and not elevenlabs_key_exists and gemini_key_exists:
            self.log_status("ElevenLabs API key not found. Switching to Gemini.")
            self.provider_var.set("gemini")
            self.on_provider_selected()

        # Mettre à jour l'état de "Voice settings..." (activé si au moins une clé)
        self.update_voice_settings_enabled()

    def rebuild_tts_provider_menu(self):
        """
        Reconstruit entièrement le menu 'Settings' dans l'ordre attendu.
        - Voice settings... (activé si au moins une clé)
        - Séparateur
        - TTS provider (cascade si 2 clés, sinon simple entrée désactivée sans flèche)
        - Séparateur
        - Manage API Keys...
        - (Windows/Linux uniquement) Séparateur + Quit
        """
        import keyring, sys

        gemini_key_exists = bool(keyring.get_password("PodcastGenerator", "gemini_api_key"))
        elevenlabs_key_exists = bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))
        both_keys = gemini_key_exists and elevenlabs_key_exists
        has_any_key = gemini_key_exists or elevenlabs_key_exists

        # Vider et reconstruire le menu Settings dans l'ordre
        self.settings_menu.delete(0, 'end')

        # 1) Voice settings...
        self.settings_menu.add_command(
            label="Voice settings...",
            command=self.open_settings_window,
            state=('normal' if has_any_key else 'disabled')
        )

        # 2) Séparateur
        self.settings_menu.add_separator()

        # 3) TTS provider
        if both_keys:
            # Cascade avec flèche
            self.tts_submenu = tk.Menu(self.settings_menu, tearoff=0)
            self.tts_submenu.add_radiobutton(label="Gemini", variable=self.provider_var, value="gemini",
                                             command=self.on_provider_selected)
            self.tts_submenu.add_radiobutton(label="ElevenLabs", variable=self.provider_var, value="elevenlabs",
                                             command=self.on_provider_selected)
            self.settings_menu.add_cascade(label="TTS provider", menu=self.tts_submenu)

            # 4) Séparateur
            self.settings_menu.add_separator()
        else:
            # Entrée simple désactivée (pas de flèche)
            self.tts_submenu = None



        # 5) Manage API Keys...
        self.settings_menu.add_command(label="Manage API Keys...", command=self.open_api_keys_window)

        # 6) Quit (Windows/Linux uniquement, macOS a déjà Quit dans le menu application)
        if sys.platform != "darwin":
            self.settings_menu.add_separator()
            self.settings_menu.add_command(label="Quit", command=self.root.quit)

    def update_voice_settings_enabled(self):
        """Active 'Voice settings...' si au moins une clé API est configurée, sinon désactive."""
        import keyring
        has_any_key = bool(keyring.get_password("PodcastGenerator", "gemini_api_key")) or \
                      bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))
        idx = self._find_menu_index_by_label(self.settings_menu, "Voice settings...")
        if idx is not None:
            self.settings_menu.entryconfig(idx, state='normal' if has_any_key else 'disabled')
            # Protéger l'accès au bouton si l'initialisation n'est pas terminée.
            if hasattr(self, "generate_button") and self.generate_button:
                self.generate_button.config(state='normal' if has_any_key else 'disabled')
        
    def _find_menu_index_by_label(self, menu: tk.Menu, label: str):
        """Retourne l'index d'une entrée de menu par son label, ou None si absent."""
        try:
            end_index = menu.index('end')
            if end_index is None:
                return None
            for i in range(end_index + 1):
                try:
                    if menu.entrycget(i, 'label') == label:
                        return i
                except tk.TclError:
                    continue
        except tk.TclError:
            return None
        return None

    def open_api_keys_window(self):
        """Opens the API keys management window."""
        # Désactiver le menu Settings pendant l'ouverture
        self.menubar.entryconfig("Settings", state="disabled")
        win = APIKeysWindow(self.root, self.on_api_keys_window_close)
        return win

    def on_api_keys_window_close(self):
        """Callback to re-enable the TTS menu when API keys window is closed."""
        self.menubar.entryconfig("Settings", state="normal")
        # Reconstruit dynamiquement le sous-menu selon les clés et met à jour l'état de l'entrée Voice settings
        self.rebuild_tts_provider_menu()
        self.update_provider_menu_state()
        self.update_voice_settings_enabled()
        # Si ElevenLabs est actif, rafraîchir le quota affiché
        if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

    def load_settings(self):
        """Loads settings from the JSON file."""
        try:
            with open(self.settings_filepath, 'r') as f:
                settings = json.load(f)
                # Load the settings as they are, preserving the rich dictionary for ElevenLabs.
                # The data will be flattened only when needed (right before generation).
                tts_provider = settings.get("tts_provider", self.DEFAULT_APP_SETTINGS["tts_provider"])
                speaker_voices = settings.get("speaker_voices", self.DEFAULT_APP_SETTINGS["speaker_voices"].copy())
                speaker_voices_elevenlabs = settings.get("speaker_voices_elevenlabs", self.DEFAULT_APP_SETTINGS["speaker_voices_elevenlabs"].copy())
                elevenlabs_quota_cache = settings.get("elevenlabs_quota_cache", None)
                
                return {
                    "tts_provider": tts_provider,
                    "speaker_voices": speaker_voices,
                    "speaker_voices_elevenlabs": speaker_voices_elevenlabs,
                    "elevenlabs_quota_cache": elevenlabs_quota_cache
                }
        except (FileNotFoundError, json.JSONDecodeError):
            # Returns default app settings if the file does not exist or is corrupt
            return json.loads(json.dumps(self.DEFAULT_APP_SETTINGS))

    def save_settings(self, settings_to_save):
        """Saves the settings to the JSON file."""
        self.app_settings = settings_to_save
        try:
            os.makedirs(self.app_data_dir, exist_ok=True)  # Ensures the directory exists
            with open(self.settings_filepath, 'w') as f:
                json.dump(self.app_settings, f, indent=4)
            #self.log_status("Settings saved successfully.")
        except IOError as e:
            messagebox.showerror("Saving Error", f"Cannot save settings to file:\n{e}", parent=self.root)
            self.logger.error(f"Saving error for settings: {e}")

    # 2. Replace the update_elevenlabs_quota_in_status method in PodcastGeneratorApp class
    def update_elevenlabs_quota_in_status(self):
        """Fetches ElevenLabs quota in a background thread and updates the status label."""
        import keyring
        import threading

        key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
        if not key:
            self.elevenlabs_quota_text = None
            # Clear cache if no key
            self.app_settings["elevenlabs_quota_cache"] = None
            self.save_settings(self.app_settings)
            self.root.after(0, self._update_provider_label)
            return

        def _save_quota_cache(text: str):
            try:
                self.app_settings["elevenlabs_quota_cache"] = {
                    "text": text,
                    "timestamp": datetime.now(datetime.UTC).isoformat().replace("+00:00", "Z")
                }
                self.save_settings(self.app_settings)
            except Exception:
                pass

        def fetch_and_update():
            try:
                # Use the new v3-compatible quota function
                quota_text = update_elevenlabs_quota(key, self.log_status)
                if quota_text:
                    self.elevenlabs_quota_text = quota_text
                    _save_quota_cache(quota_text)
                else:
                    self.elevenlabs_quota_text = "TTS Provider: ElevenLabs v3 - Quota unavailable"
                    _save_quota_cache(self.elevenlabs_quota_text)
            except Exception as e:
                self.logger.error(f"Error fetching ElevenLabs quota: {e}", exc_info=True)
                self.elevenlabs_quota_text = "TTS Provider: ElevenLabs v3 - Network error"
                _save_quota_cache(self.elevenlabs_quota_text)
            finally:
                # Always schedule the UI update from the main thread
                self.root.after(0, self._update_provider_label)

        threading.Thread(target=fetch_and_update, daemon=True).start()

    def open_settings_window(self):
        """Opens the settings management window."""
        # Disable the button while the window is open to avoid duplicates
        self.menubar.entryconfig("Settings", state="disabled")
        from settings_window import VoiceSettingsWindow
        VoiceSettingsWindow(
            self.root,
            current_settings=self.app_settings,
            save_callback=self.save_settings,
            close_callback=self.on_settings_window_close,
            default_settings=self.DEFAULT_APP_SETTINGS,
            preloaded_elevenlabs_voices=self.elevenlabs_voices_cache,
            play_gemini_sample_callback=self.play_gemini_voice_sample,
            play_elevenlabs_sample_callback=self.play_elevenlabs_voice_sample
        )

    def show_about_window(self):
        """Displays the 'About' window."""
        AboutWindow(self.root)

    def open_documentation(self):
        """Opens the link to the documentation or the repository."""
        webbrowser.open_new_tab("https://github.com/laurentftech/Podcast_generator")

    def log_status(self, message: str):
        self.log_queue.put(message)

    def poll_log_queue(self):
        # We only process one message at a time to avoid blocking the event loop.
        # This ensures the interface remains responsive and can handle other tasks
        # (like on_generation_complete) between log displays.
        try:
            message = self.log_queue.get_nowait()
            if isinstance(message, tuple):
                msg_type = message[0]
                if msg_type == 'GENERATION_COMPLETE':
                    self.on_generation_complete(success=message[1])
                elif msg_type == 'UPDATE_PLAY_BUTTON':
                    self.play_button.config(text=message[1], state=message[2])
            else:
                self._update_log(message)
        except queue.Empty:
            pass  # The queue is empty, do nothing
        self.root.after(100, self.poll_log_queue)  # Check the queue every 100 ms

    def _update_log(self, message):
        self.log_text.config(state='normal')
        self.log_text.insert(tk.END, message + "\n")
        self.log_text.see(tk.END)
        self.log_text.config(state='disabled')

    def clear_log(self):
        """Clears the log text area."""
        self.log_text.config(state='normal')
        self.log_text.delete('1.0', tk.END)
        self.log_text.config(state='disabled')

    def load_script_from_file(self):
        """Opens a dialog to load a .txt file into the script area."""
        filepath = filedialog.askopenfilename(
            title="Open a script file",
            filetypes=(("Text files", "*.txt"), ("All files", "*.*")),
            parent=self.root
        )
        if not filepath:
            return

        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                self.script_text.delete('1.0', tk.END)
                self.script_text.insert('1.0', f.read())
            self.log_status(f"Script loaded from: {os.path.basename(filepath)}")
        except Exception as e:
            messagebox.showerror("Reading error", f"Cannot read the file:\n{e}", parent=self.root)
            self.logger.error(f"Error reading the script: {e}")

    def start_generation_thread(self):
        """Starts the generation in a separate thread to avoid freezing the UI."""
        script_content = self.script_text.get("1.0", tk.END).strip()
        if not script_content:
            messagebox.showwarning("Empty script", "Please enter or load a script before starting generation.",
                                   parent=self.root)
            return

        self.last_generated_script = script_content # Store script for demo

        # --- Validate Speaker Voices ---
        try:
            missing_speakers, configured_speakers = validate_speakers(script_content, self.app_settings)
        except ValueError as e:
            # Règle Gemini: plus de 2 speakers -> erreur bloquante
            messagebox.showerror("Configuration Error", str(e), parent=self.root)
            return

        if missing_speakers:
            missing_speakers_str = ", ".join(missing_speakers)
            configured_str = ", ".join(configured_speakers) if configured_speakers else "None"
            messagebox.showerror(
                "Configuration Error",
                f"The following speakers from the script do not have an assigned voice:\n\n"
                f"Missing speakers: {missing_speakers_str}\n\n"
                f"Configured speakers: {configured_str}\n\n"
                f"Please configure their voices in 'Options -> Voice Settings' before continuing.",
                parent=self.root
            )
            return

        # Ask the user where to save the output file
        output_filepath = filedialog.asksaveasfilename(
            title="Save podcast as...",
            defaultextension=".mp3",
            filetypes=(
                ("MP3", "*.mp3"),
                ("WAV", "*.wav"),
                ("All files", "*.*")
            ),
            initialdir=os.path.expanduser("~/Downloads"),
            parent=self.root
        )

        if not output_filepath:
            self.log_status("Generation cancelled by user.")
            return

        # Disable buttons during generation
        self.generate_button.config(state='disabled')
        self.load_button.config(state='disabled')
        self.play_button.config(state='disabled')
        self.show_button.config(state='disabled')
        self.actions_menu.entryconfig("Generate HTML Demo...", state='disabled')
        self.menubar.entryconfig("Settings", state="disabled")

        # Show and start the progress bar
        self.clear_log()

        self.progress_bar.pack(fill=tk.X, pady=(10, 0), before=self.button_frame)
        self.progress_bar.start()

        thread = threading.Thread(
            target=self.run_generation,
            args=(script_content, output_filepath, self.app_settings, self.api_key)
        )
        thread.daemon = True
        thread.start()

    def run_generation(self, script_content, output_filepath, app_settings, api_key):
        """The function executed by the thread."""
        
        # --- Data Sanitization ---
        # Create a "clean" version of app_settings for the backend.
        # This ensures we only pass the voice ID to ElevenLabs, not the whole object.
        app_settings_clean = {
            "tts_provider": app_settings.get("tts_provider"),
            "speaker_voices": app_settings.get("speaker_voices", {})
        }
        
        # Nettoyage des voix Gemini: convertir "Name - Desc" -> "Name"
        gemini_clean = {}
        try:
            for speaker, voice in app_settings_clean.get("speaker_voices", {}).items():
                if isinstance(voice, str) and " - " in voice:
                    gemini_clean[speaker] = voice.split(" - ", 1)[0].strip()
                else:
                    gemini_clean[speaker] = voice
        except Exception:
            gemini_clean = app_settings_clean.get("speaker_voices", {})
        app_settings_clean["speaker_voices"] = gemini_clean

        elevenlabs_mapping_clean = {}
        elevenlabs_mapping_raw = app_settings.get("speaker_voices_elevenlabs", {})
        for speaker, data in elevenlabs_mapping_raw.items():
            if isinstance(data, dict):
                # New format: extract just the ID
                elevenlabs_mapping_clean[speaker] = data.get('id', '')
            else:
                # Legacy format: use the string as-is
                elevenlabs_mapping_clean[speaker] = data
        
        app_settings_clean["speaker_voices_elevenlabs"] = elevenlabs_mapping_clean
        # --- End of Data Sanitization ---

        generated_filepath = None
        try:
            self.logger.info("Starting generation thread.")
            self.log_status(f"Starting generation to '{os.path.basename(output_filepath)}'...")
            generated_filepath = self.generate_func(
                script_text=script_content,
                app_settings=app_settings_clean,  # Pass the clean version
                output_filepath=output_filepath,
                status_callback=self.log_status,
                api_key=api_key,
                parent_window=self.root
            )
            if generated_filepath:
                self.last_generated_filepath = generated_filepath
                self.logger.info(f"Generation completed successfully. File: {generated_filepath}")
                self.log_status(
                    f"\n--- Generation completed successfully! File: {os.path.basename(generated_filepath)} ---")
            else:
                self.logger.warning("Generation function completed without returning a file path.")
                self.log_status("\n--- Generation failed. Please check the logs. ---")
        except Exception as e:
            self.logger.error(f"Unhandled error in generation thread: {e}", exc_info=True)
            self.log_status(f"A critical error occurred in the thread: {e}")
            generated_filepath = None  # Ensure the status is 'failure'
        finally:
            # We use the queue, our reliable communication channel,
            # to signal the end of the generation and its status (success/failure).
            success = bool(generated_filepath)
            self.log_queue.put(('GENERATION_COMPLETE', success))

    def on_generation_complete(self, success: bool):
        if success:
            self.root.bell()
            if self.ffplay_path:
                self.show_button.config(state='normal')
                self.play_button.config(state='normal')
            # Enable demo button only if MFA is available
            self.actions_menu.entryconfig("Generate HTML Demo...", state='normal' if self.is_mfa_available else 'disabled')
            if self.app_settings.get("tts_provider").lower() == "elevenlabs":
                self.update_elevenlabs_quota_in_status()

        self.progress_bar.stop()
        self.generate_button.config(state='normal')
        self.load_button.config(state='normal')
        self.menubar.entryconfig("Settings", state="normal")
        if self.progress_bar.winfo_ismapped():
            self.progress_bar.pack_forget()
        self.log_text.config(state='disabled')  # Disable the log area at the very end

    def start_demo_generation_thread(self):
        """Starts the HTML demo generation in a separate thread."""
        if not self.last_generated_filepath or not self.last_generated_script:
            messagebox.showwarning("No Data", "Please generate a podcast first before creating a demo.", parent=self.root)
            return

        self.log_status("Starting HTML demo generation...")
        self.actions_menu.entryconfig("Generate HTML Demo...", state='disabled')

        thread = threading.Thread(
            target=self.run_demo_generation,
            args=(self.last_generated_script, self.last_generated_filepath)
        )
        thread.daemon = True
        thread.start()

    def run_demo_generation(self, script_content: str, audio_filepath: str):
        """The function executed by the demo generation thread."""
        temp_script_file = None
        try:
            # aeneas requires a file, so we create a temporary one
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".txt", encoding='utf-8') as f:
                f.write(script_content)
                temp_script_file = f.name

            # Call the function from generate_podcast
            create_html_demo(temp_script_file, audio_filepath, self.log_status)

        except Exception as e:
            self.logger.error(f"Error during demo generation: {e}", exc_info=True)
            self.log_status(f"An error occurred during demo generation: {e}")
        finally:
            # Re-enable the button on the main thread
            if self.root.winfo_exists():
                self.root.after(0, lambda: self.actions_menu.entryconfig("Generate HTML Demo...", state='normal'))
            # Clean up the temporary file
            if temp_script_file and os.path.exists(temp_script_file):
                os.remove(temp_script_file)

    def open_file_location(self):
        """Opens the folder containing the last generated file and selects it."""
        if not self.last_generated_filepath or not os.path.exists(self.last_generated_filepath):
            messagebox.showerror("File not found", "The generated audio file was not found or is no longer accessible.")
            return

        try:
            if sys.platform == "darwin":  # macOS
                # 'open -R' reveals the file in Finder
                subprocess.run(["open", "-R", self.last_generated_filepath], check=True)
            elif sys.platform == "win32":  # Windows
                # For explorer.exe, it's more reliable to use shell=True and pass
                # the command as a string, with the path properly quoted.
                filepath = os.path.normpath(self.last_generated_filepath)
                subprocess.run(f'explorer /select,"{filepath}"', shell=True)
            else:  # Linux and others (opens the containing folder)
                subprocess.run(["xdg-open", os.path.dirname(self.last_generated_filepath)], check=True)
        except (FileNotFoundError, subprocess.CalledProcessError) as e:
            messagebox.showerror("Error", f"Unable to open the file manager.\n"
                                          f"Check that system tools are accessible.\n\nError: {e}")

    def play_last_generated_file(self):
        """Plays or stops the playback of the last generated audio file."""
        if self.playback_obj and self.playback_obj.poll() is None:
            self.playback_obj.terminate()  # Stops the ffplay process if running
            return

        if not self.ffplay_path:
            messagebox.showerror(
                "Audio player not found",
                "The 'ffplay' command (part of FFmpeg) was not found.\n\n"
                "Playback is disabled. Please ensure FFmpeg is properly installed."
            )
            self.play_button.config(state='disabled')
            return

        if not self.last_generated_filepath or not os.path.exists(self.last_generated_filepath):
            messagebox.showerror("File not found", "The generated audio file was not found or is no longer accessible.")
            return

        threading.Thread(target=self._play_in_thread, daemon=True).start()

    def _play_in_thread(self):
        """The playback function executed in a separate thread."""
        try:
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW

            self.log_queue.put(('UPDATE_PLAY_BUTTON', '⏹️ Stop', 'normal'))
            command = [self.ffplay_path, "-nodisp", "-autoexit", "-loglevel", "quiet", self.last_generated_filepath]
            self.playback_obj = subprocess.Popen(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                                 creationflags=creation_flags)
            self.playback_obj.wait()
        except Exception as e:
            self.logger.error(f"Audio playback error with ffplay: {e}", exc_info=True)
            self.log_status(f"Audio playback error: {e}")
        finally:
            self.playback_obj = None
            if self.root.winfo_exists():
                self.log_queue.put(('UPDATE_PLAY_BUTTON', '▶️ Play', 'normal'))

    def _reset_active_button(self):
        """Resets the currently active play button to its default state."""
        if self._active_play_button:
            try:
                if self._active_play_button.winfo_exists():
                    self._active_play_button.config(text="▶")
            except (tk.TclError, AttributeError):
                pass  # Widget might have been destroyed
        self._active_play_button = None

    def play_gemini_voice_sample(self, button: tk.Button, voice_name: str):
        """Plays a voice sample for the given Gemini voice name."""
        sample_filename = f"{voice_name}.mp3"
        sample_path = get_asset_path(os.path.join("samples", "gemini_voices", sample_filename))

        if not sample_path:
            self.log_status(f"Sample for voice '{voice_name}' not found.")
            return
        self._play_sample(button, sample_path)

    def play_elevenlabs_voice_sample(self, button: tk.Button, voice_id: str, preview_url: str):
        """Plays a voice sample for ElevenLabs from a URL."""
        if not preview_url:
            self.log_status(f"No preview available for voice ID '{voice_id}'.")
            return
        self._play_sample(button, preview_url)

    def _stop_sample_playback(self):
        """Stops any active sample playback and resets associated UI elements."""
        if self.sample_poll_id:
            self.root.after_cancel(self.sample_poll_id)
            self.sample_poll_id = None

        if self.sample_playback_obj and self.sample_playback_obj.poll() is None:
            self.sample_playback_obj.terminate()
            self.sample_playback_obj = None
            self._reset_active_button()

    def _poll_sample_playback(self):
        """Periodically checks if the sample playback process has finished."""
        if self.sample_playback_obj:
            if self.sample_playback_obj.poll() is not None:  # Process has finished
                self.sample_playback_obj = None
                self._reset_active_button()
                if self.sample_poll_id:
                    self.root.after_cancel(self.sample_poll_id)
                    self.sample_poll_id = None
            else:  # Still playing, schedule next check
                self.sample_poll_id = self.root.after(250, self._poll_sample_playback)
        elif self.sample_poll_id: # No process but polling is scheduled, so cancel it
            self.root.after_cancel(self.sample_poll_id)
            self.sample_poll_id = None

    def _play_sample(self, button: tk.Button, sample_source: str):
        """
        Plays a voice sample using a polling mechanism to update the UI,
        which is more robust than using a separate thread's finally block.
        """
        button_that_was_playing = self._active_play_button
        self._stop_sample_playback()

        # If the button we just clicked was the one playing, our only job was to stop it.
        if button_that_was_playing == button:
            return

        # --- Start new playback ---
        self._active_play_button = button
        try:
            if button.winfo_exists():
                button.config(text="⏸")
        except (tk.TclError, AttributeError):
            self._reset_active_button()
            return

        if not self.ffplay_path:
            messagebox.showwarning("Player Not Found", "ffplay (part of FFmpeg) is required to play voice samples.", parent=self.root)
            self._reset_active_button()
            return

        try:
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW

            command = [self.ffplay_path, "-nodisp", "-autoexit", "-loglevel", "quiet", sample_source]
            self.sample_playback_obj = subprocess.Popen(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                                         creationflags=creation_flags)
            # Start polling for completion
            self._poll_sample_playback()
        except Exception as e:
            self.logger.error(f"Voice sample playback error: {e}", exc_info=True)
            self._reset_active_button()
            self.sample_playback_obj = None

    def on_settings_window_close(self):
        self._stop_sample_playback()
        self.menubar.entryconfig("Settings", state="normal")
        self._update_provider_label()
        self.provider_var.set(self.app_settings.get("tts_provider", "elevenlabs").lower())
        self.update_provider_menu_state()
        if self.app_settings.get("tts_provider", "").lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

    def _update_provider_label(self):
        """Updates the provider label based on the current provider and cached quota text."""
        current_provider_raw = self.app_settings.get("tts_provider", "elevenlabs")
        current_provider_display = current_provider_raw.title()
        text_to_display = f"TTS Provider: {current_provider_display}"
        
        # Si ElevenLabs est actif et qu’un quota est connu, afficher le quota
        if current_provider_raw.lower() == "elevenlabs" and self.elevenlabs_quota_text:
            text_to_display = self.elevenlabs_quota_text
        
        if hasattr(self, 'provider_label'):
            self.provider_label.config(text=text_to_display)

    def _schedule_provider_label_refresh(self, delay_ms=2000, retries=5):
        """Planifie des rafraîchissements du provider_label après un délai, avec quelques tentatives."""
        def _try_refresh(attempt=1):
            # Met à jour le label avec l’info la plus récente disponible
            self._update_provider_label()
            # Si ElevenLabs est actif et que le quota n'est pas encore connu, retente plus tard
            if (
                attempt < retries
                and self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs"
                and not self.elevenlabs_quota_text
            ):
                self.root.after(delay_ms, lambda: _try_refresh(attempt + 1))
        # Premier essai après delay_ms
        self.root.after(delay_ms, _try_refresh)


class APIKeysWindow(tk.Toplevel):
    def __init__(self, parent, close_callback):
        super().__init__(parent)
        self.title("Welcome to Podcast Generator!")
        self.transient(parent)
        self.grab_set()
        self.resizable(False, False)
        self.close_callback = close_callback
        self.protocol("WM_DELETE_WINDOW", self.on_close)

        main_frame = tk.Frame(self, padx=20, pady=15)
        main_frame.pack(fill=tk.BOTH, expand=True)

        tk.Label(main_frame, text="Manage API Keys", font=('Helvetica', 12, 'bold')).pack(pady=(0, 15))
        # Message de bienvenue (en anglais) pour guider l'utilisateur
        welcome_text = (
            "Welcome!\n"
            "Podcast Generator is a tool that generates podcasts using AI.\n"
            "To use it, you need to configure at least one API key for TTS (Text-to-Speech).\n"
            "You can set your ElevenLabs (and/or Google Gemini)  API keys below. They will be stored securely in your system.\n"
        )
        tk.Label(
            main_frame,
            text=welcome_text,
            justify="left",
            wraplength=520
        ).pack(anchor="w", pady=(0, 12))

        # ElevenLabs API Key section
        elevenlabs_frame = tk.LabelFrame(main_frame, text="ElevenLabs API", padx=10, pady=10)
        elevenlabs_frame.pack(fill=tk.X, pady=(0, 10))

        # Note sur les permissions minimales requises
        tk.Label(
            elevenlabs_frame,
            text="Minimum required permissions in ElevenLabs API settings:\n"
                 "• Text to Speech: Has access\n"
                 "• User: Read only\n"
                 "• Voices: Read only",
            justify="left",
            wraplength=520
        ).pack(anchor="w", pady=(0, 6))
        # Lien cliquable vers la page pour obtenir la clé ElevenLabs
        elevenlabs_link = tk.Label(elevenlabs_frame, text="Get an ElevenLabs API key (affiliate)", fg="blue", cursor="hand2")
        elevenlabs_link.pack(anchor="w", pady=(0, 6))
        elevenlabs_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://try.elevenlabs.io/zobct2wsp98z"))

        self.elevenlabs_status_label = tk.Label(elevenlabs_frame, text="", fg="green")
        self.elevenlabs_status_label.pack(anchor="w", pady=(0, 5))

        elevenlabs_button_frame = tk.Frame(elevenlabs_frame)
        elevenlabs_button_frame.pack(fill=tk.X)

        tk.Button(elevenlabs_button_frame, text="Set/Update Key", command=lambda: self.set_api_key("elevenlabs")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(elevenlabs_button_frame, text="Remove Key", command=lambda: self.remove_api_key("elevenlabs")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(elevenlabs_button_frame, text="Test Key", command=lambda: self.test_api_key("elevenlabs")).pack(
            side=tk.LEFT)

        # Gemini API Key section
        gemini_frame = tk.LabelFrame(main_frame, text="Google Gemini API", padx=10, pady=10)
        gemini_frame.pack(fill=tk.X, pady=(0, 10))

        gemini_link = tk.Label(gemini_frame, text="Get a Gemini API key", fg="blue", cursor="hand2")
        gemini_link.pack(anchor="w", pady=(0, 6))
        gemini_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://aistudio.google.com/app/apikey"))
        self.gemini_status_label = tk.Label(gemini_frame, text="", fg="green")
        self.gemini_status_label.pack(anchor="w", pady=(0, 5))

        gemini_button_frame = tk.Frame(gemini_frame)
        gemini_button_frame.pack(fill=tk.X)

        tk.Button(gemini_button_frame, text="Set/Update Key", command=lambda: self.set_api_key("gemini")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(gemini_button_frame, text="Remove Key", command=lambda: self.remove_api_key("gemini")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(gemini_button_frame, text="Test Key", command=lambda: self.test_api_key("gemini")).pack(side=tk.LEFT)

        # Close button
        tk.Button(main_frame, text="Close", command=self.on_close).pack(pady=(15, 0))

        # Update status on window creation
        self.update_status()

    def on_close(self):
        """Handle window close event."""
        if self.close_callback:
            self.close_callback()
        self.destroy()

    def update_status(self):
        """Update the status labels for both APIs."""
        import keyring

        # Check Gemini key
        gemini_key = keyring.get_password("PodcastGenerator", "gemini_api_key")
        if gemini_key:
            self.gemini_status_label.config(text="✓ API key is configured", fg="green")
        else:
            self.gemini_status_label.config(text="✗ No API key configured", fg="red")

        # Check ElevenLabs key
        elevenlabs_key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
        if elevenlabs_key:
            self.elevenlabs_status_label.config(text="✓ API key is configured", fg="green")
        else:
            self.elevenlabs_status_label.config(text="✗ No API key configured", fg="red")

    def set_api_key(self, service: str):
        """Set or update an API key for the specified service."""
        import keyring
        from tkinter import simpledialog

        config = SERVICE_CONFIG.get(service)
        if not config: return

        new_key = simpledialog.askstring(config["title"], f"Enter your {config['title']}:", parent=self, show="*")
        if new_key and new_key.strip():
            keyring.set_password("PodcastGenerator", config["account"], new_key.strip())
            messagebox.showinfo("Success", f"{config['title']} has been saved securely.", parent=self)
            self.update_status()
        elif new_key is not None:  # User clicked OK but entered empty key
            messagebox.showwarning("Invalid Key", "API key cannot be empty.", parent=self)

    def remove_api_key(self, service: str):
        """Remove an API key for the specified service."""
        import keyring
        config = SERVICE_CONFIG.get(service)
        if not config: return

        if messagebox.askyesno("Confirm Removal", f"Are you sure you want to remove the {config['title']}?", parent=self):
            try:
                keyring.delete_password("PodcastGenerator", config["account"])
                messagebox.showinfo("Success", f"{config['title']} has been removed.", parent=self)
            except keyring.errors.PasswordDeleteError:
                messagebox.showinfo("Info", f"No {config['title']} was stored.", parent=self)
            self.update_status()

    def test_api_key(self, service: str):
        """Test an API key for the specified service."""
        import keyring
        import requests
        from tkinter import messagebox

        if service == "elevenlabs":
            key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
            if not key:
                messagebox.showwarning("No Key", "No ElevenLabs API key is configured.", parent=self)
                return

            # Test ElevenLabs API
            try:
                headers = {"xi-api-key": key}
                response = requests.get("https://api.elevenlabs.io/v1/user", headers=headers, timeout=10)

                if response.status_code == 200:
                    user_data = response.json()
                    subscription = user_data.get('subscription', {}).get('tier', 'Unknown')
                    char_count = user_data.get('subscription', {}).get('character_count', 'Unknown')
                    char_limit = user_data.get('subscription', {}).get('character_limit', 'Unknown')
                    
                    messagebox.showinfo("Success",  # Restoring more detailed message
                                        f"ElevenLabs API key is valid! (API v1)\n\n"
                                        f"Subscription: {subscription}\n"
                                        f"Usage: {char_count} / {char_limit} characters\n\n"
                                        f"⚠ Using v1 compatibility mode",
                                        parent=self)

                elif response.status_code == 401:
                    try:
                        error_detail = response.json().get('detail', {})
                        if isinstance(error_detail, dict):
                            error_msg = error_detail.get('message', 'Invalid API key')
                        else:
                            error_msg = str(error_detail)
                    except:
                        error_msg = "Invalid or expired API key"

                    messagebox.showerror("Authentication Error",
                                         f"ElevenLabs API key test failed (401 Unauthorized):\n\n"
                                         f"{error_msg}\n\n"
                                         f"Please check:\n"
                                         f"• Key is correct and complete\n"
                                         f"• Key hasn't expired\n"
                                         f"• Account is active on elevenlabs.io", parent=self)
                else:
                    try:
                        error_detail = response.json()
                        error_msg = str(error_detail)
                    except:
                        error_msg = response.text[:200] if response.text else "Unknown error"

                    messagebox.showerror("Error",
                                         f"ElevenLabs API key test failed: {response.status_code}\n\n"
                                         f"Details: {error_msg}", parent=self)

            except requests.exceptions.RequestException as e:
                messagebox.showerror("Network Error", f"Failed to connect to ElevenLabs API:\n{str(e)}", parent=self)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to test ElevenLabs API key: {str(e)}", parent=self)

        else:
            # Gemini testing code
            key = keyring.get_password("PodcastGenerator", "gemini_api_key")
            if not key:
                messagebox.showwarning("No Key", "No Gemini API key is configured.", parent=self)
                return

            # Test Gemini API
            try:
                from google import genai
                client = genai.Client(api_key=key)
                # Simple test request
                models = list(client.models.list())
                if models:
                    messagebox.showinfo("Success", f"Gemini API key is valid!", parent=self)
                else:
                    messagebox.showwarning("Warning", "Gemini API key appears valid but no models accessible.",
                                           parent=self)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to test Gemini API key: {str(e)}", parent=self)

    def on_close(self):
        """Handle window closing."""
        self.close_callback()
        self.destroy()


# ... existing code ...

class AboutWindow(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("About Podcast Generator")
        self.transient(parent)
        self.grab_set()
        self.resizable(False, False)

        main_frame = tk.Frame(self, padx=20, pady=15)
        main_frame.pack(fill=tk.BOTH, expand=True)

        tk.Label(main_frame, text=f"Podcast Generator v{get_app_version()}", font=('Helvetica', 12, 'bold')).pack(
            pady=(0, 5))
        tk.Label(main_frame, text=f"Copyright (c) {datetime.now().year} Laurent FRANCOISE").pack()
        tk.Label(main_frame, text="Licence : MIT License").pack(pady=(0, 15))

        support_frame = tk.LabelFrame(main_frame, text="Support the projet", padx=10, pady=10)
        support_frame.pack(fill=tk.X, pady=(0, 10))

        tk.Label(support_frame, text="If this application is useful to you, you can support its development:").pack(
            pady=(0, 5))

        coffee_link = tk.Label(support_frame, text="❤️ Buy Me a Coffee", fg="blue", cursor="hand2",
                               font=('Helvetica', 10, 'bold'))
        coffee_link.pack(pady=(0, 5))
        coffee_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://buymeacoffee.com/laurentftech"))

        credits_frame = tk.LabelFrame(main_frame, text="Credits and Acknowledgements", padx=10, pady=10)
        credits_frame.pack(fill=tk.X, pady=(0, 10))

        # Gemini API link
        gemini_frame = tk.Frame(credits_frame)
        gemini_frame.pack(fill=tk.X, pady=2)
        tk.Label(gemini_frame, text="- Google Gemini API:").pack(side=tk.LEFT)
        link_label = tk.Label(gemini_frame, text="ai.google.dev/gemini-api", fg="blue", cursor="hand2")
        link_label.pack(side=tk.LEFT, padx=5)
        link_label.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://ai.google.dev/gemini-api"))

        # ElevenLabs API link
        elevenlabs_frame = tk.Frame(credits_frame)
        elevenlabs_frame.pack(fill=tk.X, pady=2)
        tk.Label(elevenlabs_frame, text="- ElevenLabs API:").pack(side=tk.LEFT)
        link_label2 = tk.Label(elevenlabs_frame, text="elevenlabs.io", fg="blue", cursor="hand2")
        link_label2.pack(side=tk.LEFT, padx=5)
        link_label2.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://elevenlabs.io"))

        tk.Label(credits_frame, text="- Tkinter for the graphical interface", anchor="w").pack(fill=tk.X, pady=2)

        # Flaticon link
        flaticon_frame = tk.Frame(credits_frame)
        flaticon_frame.pack(fill=tk.X, pady=2)
        tk.Label(flaticon_frame, text="- Icon by Smashicons from").pack(side=tk.LEFT)
        flaticon_link = tk.Label(flaticon_frame, text="flaticon.com", fg="blue", cursor="hand2")
        flaticon_link.pack(side=tk.LEFT, padx=5)
        flaticon_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://www.flaticon.com"))

        ok_button = tk.Button(main_frame, text="OK", command=self.destroy, width=10)
        ok_button.pack(pady=(10, 0))

        self.bind('<Return>', lambda event: ok_button.invoke())
        self.protocol("WM_DELETE_WINDOW", self.destroy)

def main():
    # Initializes the application and starts the main Tkinter loop
    # Creates the root window but hides it for now.
    # This allows for reliable display of error dialogs
    # even if the full interface initialization fails.


    root = tk.Tk()
    root.withdraw()

    # --- Import path correction ---
    # Ensures the script can find 'generate_podcast.py'
    # regardless of where it is executed from.
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        if script_dir not in sys.path:
            sys.path.insert(0, script_dir)
    except NameError:
        # __file__ is not defined in some interactive environments
        pass

    # --- Importing dependencies ---
    try:
        from generate_podcast import generate, PODCAST_SCRIPT, setup_logging, find_ffplay_path
        # Note: on n'importe plus get_api_key ici pour remplacer la saisie par la fenêtre de gestion des clés.
    except ImportError as e:
        messagebox.showerror(
            "Import Error",
            f"The file 'generate_podcast.py' was not found.\n\n"
            f"Please ensure it is in the same folder as gui.py.\n\n"
            f"Error details: {e}"
            , parent=root)
        root.destroy()
        return

    # Initializes logging before anything else
    logger = setup_logging()
    logger.info("Starting application...")

    # Create the app instance first, which populates the root window with widgets.
    # The window remains hidden for now. We pass a placeholder for the api_key.
    app = PodcastGeneratorApp(root, generate_func=generate, logger=logger, api_key="", default_script=PODCAST_SCRIPT)

    # --- API key check at startup (remplace l'ancien get_api_key) ---
    import keyring
    current_provider = app.app_settings.get("tts_provider", "elevenlabs")
    account_name = "elevenlabs_api_key" if current_provider == "elevenlabs" else "gemini_api_key"
    api_key = keyring.get_password("PodcastGenerator", account_name)

    if not api_key:
        # Ouvrir directement la fenêtre de gestion des clés et attendre sa fermeture
        win = app.open_api_keys_window()
        root.deiconify()  # s'assurer que la fenêtre parent est visible
        root.wait_window(win)

        # Re-vérifier la clé après fermeture
        api_key = keyring.get_password("PodcastGenerator", account_name)
        if not api_key:
            logger.info("Application closed because no API key was provided at startup.")
            messagebox.showwarning("API Key Required", "The application cannot start without an API key.", parent=root)
            root.destroy()
            return

    # Now that we have the key, assign it to the app and show the main window.
    app.api_key = api_key
    # Met à jour immédiatement l'état des contrôles dépendants des clés
    app.update_provider_menu_state()
    app.update_voice_settings_enabled()

    # Précharger les voix ElevenLabs au démarrage (si la clé est configurée)
    def _prefetch_elevenlabs():
        """Prefetches ElevenLabs voices using the v1 API."""
        try:
            import keyring, requests
            key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
            if not key:
                app.elevenlabs_voices_cache = []
                return

            headers = {"xi-api-key": key}

            resp = requests.get("https://api.elevenlabs.io/v1/voices", headers=headers, timeout=15)
            if resp.status_code != 200:
                app.elevenlabs_voices_cache = []
                return

            data = resp.json()
            voices = []

            for voice in data.get('voices', []):
                voice_id = voice.get('voice_id', '')
                name = voice.get('name', 'Unknown')
                category = voice.get('category', '')
                labels = voice.get('labels', {}) if voice.get('labels') else {}
                preview_url = voice.get('preview_url', '')

                accent = labels.get('accent', '')
                age = labels.get('age', '')
                gender = labels.get('gender', '')

                desc_parts = []
                if gender: desc_parts.append(str(gender).title())
                if age: desc_parts.append(str(age).title())
                if accent: desc_parts.append(str(accent))

                description = ', '.join(desc_parts) if desc_parts else str(category).title()
                display_name = f"{name} - {description}" if description else name

                voices.append({
                    'id': voice_id,
                    'name': name,
                    'display_name': display_name,
                    'category': category,
                    'labels': labels,
                    'preview_url': preview_url
                })

            voices.sort(key=lambda x: x.get('name', ''))
            app.elevenlabs_voices_cache = voices

        except Exception:
            app.elevenlabs_voices_cache = []

    import threading as _th
    _th.Thread(target=_prefetch_elevenlabs, daemon=True).start()

    root.deiconify()
    root.mainloop()


if __name__ == "__main__":
    # This is crucial for preventing infinite loops when the app is frozen
    # with PyInstaller on macOS and Windows. It must be the first call
    # in the main block.
    import multiprocessing
    multiprocessing.freeze_support()
    main()
