import tkinter as tk
from tkinter import filedialog, messagebox
import threading
import os
import subprocess
import sys
import queue
import json
import webbrowser
import tempfile
from datetime import datetime
from typing import Optional

import customtkinter
from customtkinter.windows.ctk_input_dialog import CTkInputDialog

from about_window import AboutWindow
from api_keys_window import APIKeysWindow
from generate_podcast import validate_speakers, update_elevenlabs_quota
from create_demo import create_html_demo_whisperx

# --- Versioning ---
# This file is automatically generated by setuptools-scm
try:
    from _version import __version__  # type: ignore
except Exception:
    # Fallback développement: quand _version.py n'est pas encore généré
    __version__ = "0.0.0-dev"

AVAILABLE_VOICES = {
    "Zephyr": "Bright",
    "Puck": "Upbeat",
    "Charon": "Informative",
    "Kore": "Firm",
    "Fenrir": "Excitable",
    "Leda": "Youthful",
    "Orus": "Firm",
    "Aoede": "Breezy",
    "Callirrhoe": "Easy-going",
    "Autonoe": "Bright",
    "Enceladus": "Breathy",
    "Iapetus": "Clear",
    "Umbriel": "Easy-going",
    "Algieba": "Smooth",
    "Despina": "Smooth",
    "Erinome": "Clear",
    "Algenib": "Gravelly",
    "Rasalgethi": "Informative",
    "Laomedeia": "Upbeat",
    "Achernar": "Soft",
    "Alnilam": "Firm",
    "Schedar": "Even",
    "Gacrux": "Mature",
    "Pulcherrima": "Forward",
    "Achird": "Friendly",
    "Zubenelgenubi": "Casual",
    "Vindemiatrix": "Gentle",
    "Sadachbia": "Lively",
    "Sadaltager": "Knowledgeable",
    "Sulafat": "Warm"
}

def get_app_version() -> str:
    """Gets the application version from the _version.py file."""
    return __version__


def get_asset_path(filename: str) -> Optional[str]:
    """
    Gets the absolute path to an asset, handling running from source and from
    a PyInstaller bundle.
    """
    if getattr(sys, 'frozen', False):
        # The application is frozen (packaged with PyInstaller)
        bundle_dir = sys._MEIPASS
    else:
        # The application is running in a normal Python environment
        bundle_dir = os.path.dirname(os.path.abspath(__file__))

    path = os.path.join(bundle_dir, filename)
    return path if os.path.exists(path) else None


class PodcastGeneratorApp:
    DEFAULT_APP_SETTINGS = {
        "tts_provider": "elevenlabs",
        "speaker_voices": {"John": "Schedar - Even", "Samantha": "Zephyr - Bright"},
        "speaker_voices_elevenlabs": {
            "John": {"id": "TX3LPaxmHKxFdv7VOQHJ", "display_name": "Liam - Male, Young, american"},
            "Samantha": {"id": "cgSgspJ2msm6clMCkdW9", "display_name": "Jessica - Female, Young, american"}
        },
        "elevenlabs_quota_cache": None
    }

    def __init__(self, root: tk.Tk, generate_func, logger, api_key: str, default_script: str = ""):
        self.root = root
        self.logger = logger
        self.root.title(f"Podcast Generator v{get_app_version()}")
        self.root.geometry("960x700")

        # --- customtkinter Theme and Appearance ---
        customtkinter.set_appearance_mode("dark" if self._is_system_dark_mode() else "light")
        customtkinter.set_default_color_theme("blue")

        # --- Application Icon ---
        icon_path = get_asset_path("podcast.png")
        if icon_path:
            try:
                img = tk.PhotoImage(file=icon_path)
                self.root.tk.call('wm', 'iconphoto', self.root._w, img)
            except tk.TclError: # In case of format error, continue without icon
                self.logger.warning("Could not set application icon.")

        # --- Define configuration paths ---
        from generate_podcast import get_app_data_dir, find_ffplay_path  # Local import
        self.app_data_dir = get_app_data_dir()
        self.settings_filepath = os.path.join(self.app_data_dir, "settings.json")

        self.generate_func = generate_func
        self.api_key = api_key
        self.log_queue = queue.Queue()
        self.playback_obj = None  # To keep a reference to the playback process
        self.sample_playback_obj = None  # For voice sample playback
        self._active_play_button: Optional[customtkinter.CTkButton] = None
        self.sample_poll_id = None  # For polling playback status
        self.last_generated_filepath = None
        self.last_generated_script = None  # To store script for demo generation
        self.ffplay_path = find_ffplay_path()
        self.is_whisperx_available = self.check_whisperx_availability()
        self.elevenlabs_quota_text = None  # New state variable

        self.app_settings = self.load_settings()
        self.provider_var = tk.StringVar(value=self.app_settings.get("tts_provider", "elevenlabs").lower())

        self._setup_menu()
        self._setup_widgets(default_script)

        # Provider sélectionné
        self.provider_var = tk.StringVar(value=self.app_settings.get("tts_provider", "elevenlabs").lower())
        if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

        # Cache des voix ElevenLabs préchargées
        self.elevenlabs_voices_cache = []

        self.poll_log_queue()

        # Update UI states after all widgets are created
        self.update_provider_menu_state()
        self.update_voice_settings_enabled()

        # Schedule initial quota fetch and theme watcher
        if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
            self._schedule_provider_label_refresh(delay_ms=2000, retries=5)
        self._start_theme_watcher()

        self.logger.info("Main interface initialized.")

    def check_whisperx_availability(self) -> bool:
        """Checks if WhisperX is installed and logs the result."""
        try:
            import whisperx
            self.logger.info("WhisperX installation found. Demo generation is enabled.")
            return True
        except ImportError:
            self.logger.warning("WhisperX library not found. Demo generation will be disabled.")
            return False

    def _setup_menu(self):
        """Sets up the main application menu bar."""
        # --- Menu Bar (Platform-specific) ---
        self.menubar = tk.Menu(self.root)
        self.root.config(menu=self.menubar)

        if sys.platform == "darwin":  # macOS
            try:
                # Create the special "app" menu. This can fail on non-native Tcl/Tk.
                app_menu = tk.Menu(self.menubar, name='apple', tearoff=0)
                self.menubar.add_cascade(label="Podcast Generator", menu=app_menu)

                app_menu.add_command(label=f"About Podcast Generator", command=self.show_about_window)
                app_menu.add_separator()
                app_menu.add_command(label="Voice settings...", command=self.open_settings_window,
                                     accelerator="Command+,")
                app_menu.add_separator()
                # Add standard macOS services for a native feel
                app_menu.add_command(label="Services", role="services")
                app_menu.add_separator()
                app_menu.add_command(label="Hide Podcast Generator", accelerator="Command+H", role="hide")
                app_menu.add_command(label="Hide Others", accelerator="Command+Option+H", role="hideothers")
                app_menu.add_command(label="Show All", role="unhide")
                app_menu.add_separator()
                app_menu.add_command(label="Quit Podcast Generator", accelerator="Command+Q", role="quit")
            except tk.TclError:
                # Fallback for older Tcl/Tk. Clear any partially created menu.
                self.menubar.delete(0, 'end')
                # (Le menu Settings sera créé plus bas, commun à toutes les plateformes)

        # Création du menu Settings (commun à toutes les plateformes)
        self.settings_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Settings", menu=self.settings_menu)

        # Sous-menu TTS provider (n’apparaît que si 2 clés sont présentes)

        self.tts_submenu = None
        self.rebuild_tts_provider_menu()

        # Quit (pour Windows/Linux; sur macOS l'app menu expose déjà Quit)
        if sys.platform != "darwin":
            self.settings_menu.add_separator()
            self.settings_menu.add_command(label="Quit", command=self.root.quit)

        # --- Actions Menu ---
        self.actions_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Actions", menu=self.actions_menu)
        self.actions_menu.add_command(label="Generate HTML Demo...",
                                      command=self.start_demo_generation_thread,
                                      state='disabled')

        # Help Menu (common to all platforms)
        help_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Documentation (Github)...", command=self.open_documentation)
        help_menu.add_command(label="About...", command=self.show_about_window)

    def _setup_widgets(self, default_script: str):
        """Sets up the main UI widgets like text areas and buttons."""
        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_rowconfigure(0, weight=1)  # Make the main_frame expand vertically

        # --- Main Frame ---
        main_frame = customtkinter.CTkFrame(self.root, fg_color="transparent")
        main_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        main_frame.grid_columnconfigure(0, weight=1)
        main_frame.grid_rowconfigure(2, weight=1)  # Make script_text expand
        main_frame.grid_rowconfigure(4, weight=1)  # Make log_text expand

        # --- TTS Provider Status Bar ---
        status_frame = customtkinter.CTkFrame(main_frame, corner_radius=6, border_width=1)
        status_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))

        current_provider = self.app_settings.get("tts_provider", "elevenlabs").title()
        self.provider_label = customtkinter.CTkLabel(status_frame, text=f"TTS Provider: {current_provider}",
                                                     font=customtkinter.CTkFont(size=12))
        self.provider_label.pack(side=tk.LEFT, padx=10, pady=5)
        # Déclenche le rafraîchissement du quota immédiatement si ElevenLabs est actif
        if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
            self._load_cached_quota()
            self.update_elevenlabs_quota_in_status()

        # --- Script Text Area ---
        customtkinter.CTkLabel(main_frame, text="Script to read").grid(row=1, column=0, sticky="w", padx=5)
        self.script_text = customtkinter.CTkTextbox(main_frame, wrap=tk.WORD, border_width=1)
        self.script_text.grid(row=2, column=0, sticky="nsew", pady=(0, 10))
        self.script_text.insert(tk.END, default_script)

        # --- Log/Status Area ---
        customtkinter.CTkLabel(main_frame, text="Generation status").grid(row=3, column=0, sticky="w", padx=5)
        self.log_text = customtkinter.CTkTextbox(main_frame, wrap=tk.WORD, state='disabled', border_width=1, fg_color="transparent")
        self.log_text.grid(row=4, column=0, sticky="nsew")

        # --- Progress Bar Placeholder & Widget ---
        # This frame reserves space for the progress bar to avoid window resizing.
        progress_bar_height = 20
        self.progress_bar_placeholder = customtkinter.CTkFrame(main_frame, fg_color="transparent", height=progress_bar_height)
        self.progress_bar_placeholder.grid(row=5, column=0, sticky="ew")
        # Prevent children from resizing the placeholder
        self.progress_bar_placeholder.pack_propagate(False)

        self.progress_bar = customtkinter.CTkProgressBar(self.progress_bar_placeholder, mode='indeterminate', progress_color="#4CAF50")

        # --- Button Frame ---
        self.button_frame = customtkinter.CTkFrame(main_frame, fg_color="transparent")
        self.button_frame.grid(row=6, column=0, sticky="ew", pady=(10, 0))
        self.button_frame.grid_columnconfigure((0, 1, 2), weight=1)  # The 3 main buttons expand
        self.button_frame.grid_columnconfigure(3, weight=0)  # The play button has a fixed size

        # --- Buttons ---
        self.load_button = customtkinter.CTkButton(self.button_frame, text="Load a script (.txt)",
                                                   command=self.load_script_from_file)
        self.load_button.grid(row=0, column=0, sticky="ew", padx=(0, 5))

        self.generate_button = customtkinter.CTkButton(self.button_frame, text="Start generation",
                                                       command=self.start_generation_thread)
        self.generate_button.grid(row=0, column=1, sticky="ew", padx=5)

        self.show_button = customtkinter.CTkButton(self.button_frame, text="Open file location", command=self.open_file_location)
        self.show_button.grid(row=0, column=2, sticky="ew", padx=5)
        self._configure_button_state(self.show_button, enabled=False)

        self.play_button = customtkinter.CTkButton(self.button_frame, text="▶",
                                                   command=self.play_last_generated_file, width=40)
        self.play_button.grid(row=0, column=3, sticky="e", padx=(5, 0))
        self._configure_button_state(self.play_button, enabled=False)

    def _load_cached_quota(self):
        """Loads and displays the cached quota if available."""
        cached = self.app_settings.get("elevenlabs_quota_cache") or {}
        cached_text = cached.get("text")
        if cached_text:
            self.elevenlabs_quota_text = cached_text
            self._update_provider_label()

    def _is_system_dark_mode(self) -> bool:
        """Retourne True si le système (macOS ou Windows) est en mode sombre."""
        try:
            if sys.platform == "darwin":
                # AppleInterfaceStyle existe seulement en mode sombre
                proc = subprocess.run(
                    ["defaults", "read", "-g", "AppleInterfaceStyle"],
                    capture_output=True, text=True
                )
                return proc.returncode == 0 and proc.stdout.strip().lower() == "dark"

            if sys.platform == "win32":
                import winreg
                key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,
                                     r'Software\Microsoft\Windows\CurrentVersion\Themes\Personalize')
                value, _ = winreg.QueryValueEx(key, 'AppsUseLightTheme')
                winreg.CloseKey(key)
                return value == 0
        except Exception:
            # En cas d'erreur (ex: clé de registre absente, commande non trouvée), on suppose le mode clair.
            return False
        return False  # Pour les autres OS (Linux, etc.)

    def _start_theme_watcher(self, interval_ms: int = 2000):
        """Surveille le mode sombre (macOS/Windows) et met à jour le thème de l'application si l'état change."""

        def _tick():
            try:
                current = self._is_system_dark_mode()
                current_app_mode = customtkinter.get_appearance_mode().lower()
                if (current and current_app_mode != "dark") or (not current and current_app_mode != "light"):
                    customtkinter.set_appearance_mode("dark" if current else "light")
            finally:
                # Replanifie la prochaine vérification
                if self.root and self.root.winfo_exists():
                    self.root.after(interval_ms, _tick)

        # Premier tick
        if self.root and self.root.winfo_exists():
            self.root.after(interval_ms, _tick)

    def _configure_button_state(self, button: customtkinter.CTkButton, enabled: bool):
        """Configures the state and color of a button."""
        if not button or not button.winfo_exists():
            return

        if enabled:
            # Restore default theme color for the enabled state
            normal_fg_color = customtkinter.ThemeManager.theme["CTkButton"]["fg_color"]
            normal_text_color = customtkinter.ThemeManager.theme["CTkButton"]["text_color"]
            button.configure(state='normal', fg_color=normal_fg_color, text_color=normal_text_color)
        else:
            # Apply a custom, more opaque color for the disabled state
            disabled_fg_color = ("gray75", "gray30")
            # Use a readable text color for the disabled state
            disabled_text_color = ("gray10", "gray90")  # Dark gray for light mode, light gray for dark mode
            button.configure(state='disabled', fg_color=disabled_fg_color, text_color_disabled=disabled_text_color)

    def on_provider_selected(self):
        """Handles selection from the TTS Provider radio button menu."""
        new_provider = self.provider_var.get()
        # Prevent running the switch logic if the selection hasn't actually changed.
        # This can happen if the user cancels the API key dialog.
        if new_provider != self.app_settings.get("tts_provider"):
            self.switch_tts_provider(new_provider)

    def switch_tts_provider(self, provider: str):
        """Switch TTS provider, update settings, and fetch the correct API key."""
        if provider not in ["gemini", "elevenlabs"]:
            return

        from generate_podcast import get_api_key  # Local import is safe
        provider_title = "ElevenLabs v3" if provider == "elevenlabs" else provider.title()

        # Attempt to get the new API key from storage.
        # get_api_key will now return None immediately if the key is not in storage and we are in GUI mode.
        new_api_key = get_api_key(self.log_status, self.logger, parent_window=self.root, service=provider)

        # If the key is not found in storage, we need to ask the user.
        if not new_api_key:
            self.log_status(f"API key for {provider_title} not found in storage.")

            if messagebox.askyesno(
                    "API Key Required",
                    f"The API key for {provider_title} is not configured.\n\n"
                    f"Would you like to set it now?",
                    parent=self.root
            ):
                # Open the key management window and wait for it to close.
                keys_window = self.open_api_keys_window()
                self.root.wait_window(keys_window)

                # After the window is closed, try to get the key again from storage.
                new_api_key = get_api_key(self.log_status, self.logger, parent_window=self.root, service=provider)

        # If the key is still not available (user cancelled), abort the switch.
        if not new_api_key:
            self.log_status(f"API key acquisition for {provider_title} failed. Provider switch cancelled.")
            # Revert the radio button to the previous valid setting
            self.provider_var.set(self.app_settings.get("tts_provider", "elevenlabs"))
            return  # Do not show a warning, as the user has already interacted with a dialog.

        # If successful, update the API key in memory and in the settings.
        self.api_key = new_api_key
        self.app_settings["tts_provider"] = provider
        self.save_settings(self.app_settings)

        # Update UI to reflect the change
        self._update_provider_label()  # Update the label to its base state
        self.log_status(f"Successfully switched TTS provider to {provider_title}.")
        if provider == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

    def update_provider_menu_state(self):
        """
        Met à jour la disponibilité du sous-menu TTS provider en fonction des clés API.
        Le sous-menu n’apparaît que si les 2 clés sont configurées.
        """
        import keyring

        gemini_key_exists = bool(keyring.get_password("PodcastGenerator", "gemini_api_key"))
        elevenlabs_key_exists = bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))

        # (Re)construit le sous-menu dynamiquement
        self.rebuild_tts_provider_menu()

        # Cas limites: si la clé du provider courant a disparu, basculer vers l’autre si possible
        current_provider = self.provider_var.get()
        if current_provider == "gemini" and not gemini_key_exists and elevenlabs_key_exists:
            self.log_status("Gemini API key not found. Switching to ElevenLabs.")
            self.provider_var.set("elevenlabs")
            self.on_provider_selected()
        elif current_provider == "elevenlabs" and not elevenlabs_key_exists and gemini_key_exists:
            self.log_status("ElevenLabs API key not found. Switching to Gemini.")
            self.provider_var.set("gemini")
            self.on_provider_selected()

        # Mettre à jour l'état de "Voice settings..." (activé si au moins une clé)
        self.update_voice_settings_enabled()

    def rebuild_tts_provider_menu(self):
        """
        Reconstruit entièrement le menu 'Settings' dans l'ordre attendu.
        - Voice settings... (activé si au moins une clé)
        - Séparateur
        - TTS provider (cascade si 2 clés, sinon simple entrée désactivée sans flèche)
        - Séparateur
        - Manage API Keys...
        - (Windows/Linux uniquement) Séparateur + Quit
        """
        import keyring, sys

        gemini_key_exists = bool(keyring.get_password("PodcastGenerator", "gemini_api_key"))
        elevenlabs_key_exists = bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))
        both_keys = gemini_key_exists and elevenlabs_key_exists
        has_any_key = gemini_key_exists or elevenlabs_key_exists

        # Vider et reconstruire le menu Settings dans l'ordre
        self.settings_menu.delete(0, 'end')

        # 1) Voice settings...
        self.settings_menu.add_command(
            label="Voice settings...",
            command=self.open_settings_window,
            state=('normal' if has_any_key else 'disabled')
        )

        # 2) Séparateur
        self.settings_menu.add_separator()

        # 3) TTS provider
        if both_keys:
            # Cascade avec flèche
            self.tts_submenu = tk.Menu(self.settings_menu, tearoff=0)
            self.tts_submenu.add_radiobutton(label="Gemini", variable=self.provider_var, value="gemini",
                                             command=self.on_provider_selected)
            self.tts_submenu.add_radiobutton(label="ElevenLabs", variable=self.provider_var, value="elevenlabs",
                                             command=self.on_provider_selected)
            self.settings_menu.add_cascade(label="TTS provider", menu=self.tts_submenu)

            # 4) Séparateur
            self.settings_menu.add_separator()
        else:
            # Entrée simple désactivée (pas de flèche)
            self.tts_submenu = None

        # 5) Manage API Keys...
        self.settings_menu.add_command(label="Manage API Keys...", command=self.open_api_keys_window)

        # 6) Quit (Windows/Linux uniquement, macOS a déjà Quit dans le menu application)
        if sys.platform != "darwin":
            self.settings_menu.add_separator()
            self.settings_menu.add_command(label="Quit", command=self.root.quit)

    def update_voice_settings_enabled(self):
        """Active 'Voice settings...' si au moins une clé API est configurée, sinon désactive."""
        import keyring
        has_any_key = bool(keyring.get_password("PodcastGenerator", "gemini_api_key")) or \
                      bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))
        idx = self._find_menu_index_by_label(self.settings_menu, "Voice settings...")
        if idx is not None:
            self.settings_menu.entryconfig(idx, state='normal' if has_any_key else 'disabled')
            # Protéger l'accès au bouton si l'initialisation n'est pas terminée.
            if hasattr(self, "generate_button") and self.generate_button:
                self._configure_button_state(self.generate_button, enabled=has_any_key)

    def _find_menu_index_by_label(self, menu: tk.Menu, label: str):
        """Retourne l'index d'une entrée de menu par son label, ou None si absent."""
        try:
            end_index = menu.index('end')
            if end_index is None:
                return None
            for i in range(end_index + 1):
                try:
                    if menu.entrycget(i, 'label') == label:
                        return i
                except tk.TclError:
                    continue
        except tk.TclError:
            return None
        return None

    def open_api_keys_window(self):
        """Opens the API keys management window."""
        # Désactiver le menu Settings pendant l'ouverture
        self.menubar.entryconfig("Settings", state="disabled")
        win = APIKeysWindow(self.root, self.on_api_keys_window_close)
        return win

    def on_api_keys_window_close(self):
        """Callback to re-enable the TTS menu when API keys window is closed."""
        self.menubar.entryconfig("Settings", state="normal")
        # Reconstruit dynamiquement le sous-menu selon les clés et met à jour l'état de l'entrée Voice settings
        self.rebuild_tts_provider_menu()
        self.update_provider_menu_state()
        self.update_voice_settings_enabled()
        # Si ElevenLabs est actif, rafraîchir le quota affiché
        if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

    def load_settings(self):
        """Loads settings from the JSON file."""
        try:
            with open(self.settings_filepath, 'r') as f:
                settings = json.load(f)
                # Load the settings as they are, preserving the rich dictionary for ElevenLabs.
                # The data will be flattened only when needed (right before generation).
                tts_provider = settings.get("tts_provider", self.DEFAULT_APP_SETTINGS["tts_provider"])
                speaker_voices = settings.get("speaker_voices", self.DEFAULT_APP_SETTINGS["speaker_voices"].copy())
                speaker_voices_elevenlabs = settings.get("speaker_voices_elevenlabs",
                                                         self.DEFAULT_APP_SETTINGS["speaker_voices_elevenlabs"].copy())
                elevenlabs_quota_cache = settings.get("elevenlabs_quota_cache", None)

                return {
                    "tts_provider": tts_provider,
                    "speaker_voices": speaker_voices,
                    "speaker_voices_elevenlabs": speaker_voices_elevenlabs,
                    "elevenlabs_quota_cache": elevenlabs_quota_cache
                }
        except (FileNotFoundError, json.JSONDecodeError):
            # Returns default app settings if the file does not exist or is corrupt
            return json.loads(json.dumps(self.DEFAULT_APP_SETTINGS))

    def save_settings(self, settings_to_save):
        """Saves the settings to the JSON file."""
        self.app_settings = settings_to_save
        try:
            os.makedirs(self.app_data_dir, exist_ok=True)  # Ensures the directory exists
            with open(self.settings_filepath, 'w') as f:
                json.dump(self.app_settings, f, indent=4)
            # self.log_status("Settings saved successfully.")
        except IOError as e:
            messagebox.showerror("Saving Error", f"Cannot save settings to file:\n{e}", parent=self.root)
            self.logger.error(f"Saving error for settings: {e}")

    # 2. Replace the update_elevenlabs_quota_in_status method in PodcastGeneratorApp class
    def update_elevenlabs_quota_in_status(self):
        """Fetches ElevenLabs quota in a background thread and updates the status label."""
        import keyring
        import threading

        key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
        if not key:
            self.elevenlabs_quota_text = None
            # Clear cache if no key
            self.app_settings["elevenlabs_quota_cache"] = None
            self.save_settings(self.app_settings)
            self.root.after(0, self._update_provider_label)
            return

        def _save_quota_cache(text: str):
            try:
                self.app_settings["elevenlabs_quota_cache"] = {
                    "text": text,
                    "timestamp": datetime.now(datetime.UTC).isoformat().replace("+00:00", "Z")
                }
                self.save_settings(self.app_settings)
            except Exception:
                pass

        def fetch_and_update():
            try:
                # Use the new v3-compatible quota function
                quota_text = update_elevenlabs_quota(key, self.log_status)
                if quota_text:
                    self.elevenlabs_quota_text = quota_text
                    _save_quota_cache(quota_text)
                else:
                    self.elevenlabs_quota_text = "TTS Provider: ElevenLabs v3 - Quota unavailable"
                    _save_quota_cache(self.elevenlabs_quota_text)
            except Exception as e:
                self.logger.error(f"Error fetching ElevenLabs quota: {e}", exc_info=True)
                self.elevenlabs_quota_text = "TTS Provider: ElevenLabs v3 - Network error"
                _save_quota_cache(self.elevenlabs_quota_text)
            finally:
                # Always schedule the UI update from the main thread
                self.root.after(0, self._update_provider_label)

        threading.Thread(target=fetch_and_update, daemon=True).start()

    def open_settings_window(self):
        # Disable the button while the window is open to avoid duplicates
        self.menubar.entryconfig("Settings", state="disabled")

        # If the ElevenLabs voice cache is not yet populated, wait for it.
        # This prevents a race condition in the settings window where a late
        # arrival of the voice list could trigger a buggy UI refresh.
        if self.provider_var.get() == "elevenlabs" and not self.elevenlabs_voices_cache:
            self.log_status("Loading available voices from ElevenLabs...")

            def _wait_for_cache():
                if self.elevenlabs_voices_cache:
                    self.log_status("Voices loaded. Opening settings...")
                    self._show_settings_window()
                else:
                    # Check again in 200ms
                    self.root.after(200, _wait_for_cache)

            _wait_for_cache()
        else:
            # If not using ElevenLabs or cache is ready, open immediately.
            self._show_settings_window()

    def _show_settings_window(self):
        """Creates and displays the actual settings window."""
        from settings_window import VoiceSettingsWindow
        VoiceSettingsWindow(
            self.root,
            current_settings=self.app_settings,
            save_callback=self.save_settings,
            close_callback=self.on_settings_window_close,
            default_settings=self.DEFAULT_APP_SETTINGS,
            preloaded_elevenlabs_voices=self.elevenlabs_voices_cache,
            play_gemini_sample_callback=self.play_gemini_voice_sample,
            play_elevenlabs_sample_callback=self.play_elevenlabs_voice_sample
        )

    def show_about_window(self):
        """Displays the 'About' window."""
        AboutWindow(self.root, version=get_app_version())

    def open_documentation(self):
        """Opens the link to the documentation or the repository."""
        webbrowser.open_new_tab("https://github.com/laurentftech/Podcast_generator")

    def log_status(self, message: str):
        self.log_queue.put(message)

    def poll_log_queue(self):
        # We only process one message at a time to avoid blocking the event loop.
        # This ensures the interface remains responsive and can handle other tasks
        # (like on_generation_complete) between log displays.
        try:
            message = self.log_queue.get_nowait()
            if isinstance(message, tuple):
                msg_type = message[0]
                if msg_type == 'GENERATION_COMPLETE':
                    self.on_generation_complete(success=message[1])
                elif msg_type == 'UPDATE_PLAY_BUTTON':
                    is_enabled = message[2] == 'normal'
                    self._configure_button_state(self.play_button, enabled=is_enabled)
                    if self.play_button and self.play_button.winfo_exists():
                        self.play_button.configure(text=message[1])
            else:
                self._update_log(message)
        except queue.Empty:
            pass  # The queue is empty, do nothing
        self.root.after(100, self.poll_log_queue)  # Check the queue every 100 ms

    def _update_log(self, message):
        self.log_text.configure(state='normal')
        self.log_text.insert(tk.END, message + "\n")
        self.log_text.see(tk.END)
        self.log_text.configure(state='disabled')

    def clear_log(self):
        """Clears the log text area."""
        self.log_text.configure(state='normal')
        self.log_text.delete('1.0', tk.END)
        self.log_text.configure(state='disabled')

    def load_script_from_file(self):
        """Opens a dialog to load a .txt file into the script area."""
        filepath = filedialog.askopenfilename(
            title="Open a script file",
            filetypes=(("Text files", "*.txt"), ("All files", "*.*")),
            parent=self.root
        )
        if not filepath:
            return

        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                self.script_text.delete('1.0', tk.END)
                self.script_text.insert('1.0', f.read())
            self.log_status(f"Script loaded from: {os.path.basename(filepath)}")
        except Exception as e:
            messagebox.showerror("Reading error", f"Cannot read the file:\n{e}", parent=self.root)
            self.logger.error(f"Error reading the script: {e}")

    def start_generation_thread(self):
        """Starts the generation in a separate thread to avoid freezing the UI."""
        script_content = self.script_text.get("1.0", tk.END).strip()
        if not script_content:
            messagebox.showwarning("Empty script", "Please enter or load a script before starting generation.",
                                   parent=self.root)
            return

        self.last_generated_script = script_content  # Store script for demo

        # --- Validate Speaker Voices ---
        try:
            missing_speakers, configured_speakers = validate_speakers(script_content, self.app_settings)
        except ValueError as e:
            # Règle Gemini: plus de 2 speakers -> erreur bloquante
            messagebox.showerror("Configuration Error", str(e), parent=self.root)
            return

        if missing_speakers:
            missing_speakers_str = ", ".join(missing_speakers)
            configured_str = ", ".join(configured_speakers) if configured_speakers else "None"
            messagebox.showerror(
                "Configuration Error",
                f"The following speakers from the script do not have an assigned voice:\n\n"
                f"Missing speakers: {missing_speakers_str}\n\n"
                f"Configured speakers: {configured_str}\n\n"
                f"Please configure their voices in 'Options -> Voice Settings' before continuing.",
                parent=self.root
            )
            return

        # Ask the user where to save the output file
        output_filepath = filedialog.asksaveasfilename(
            title="Save podcast as...",
            defaultextension=".mp3",
            filetypes=(
                ("MP3", "*.mp3"),
                ("WAV", "*.wav"),
                ("All files", "*.*")
            ),
            initialdir=os.path.expanduser("~/Downloads"),
            parent=self.root
        )

        if not output_filepath:
            self.log_status("Generation cancelled by user.")
            return

        # Disable buttons during generation
        self._configure_button_state(self.generate_button, enabled=False)
        self._configure_button_state(self.load_button, enabled=False)
        self._configure_button_state(self.play_button, enabled=False)
        self._configure_button_state(self.show_button, enabled=False)
        self.actions_menu.entryconfig("Generate HTML Demo...", state='disabled')
        self.menubar.entryconfig("Settings", state="disabled")

        # Show and start the progress bar
        self.clear_log()

        self.progress_bar.pack(pady=5, padx=5, fill='x', expand=True)
        self.progress_bar.start()

        thread = threading.Thread(
            target=self.run_generation,
            args=(script_content, output_filepath, self.app_settings, self.api_key)
        )
        thread.daemon = True
        thread.start()

    def run_generation(self, script_content, output_filepath, app_settings, api_key):
        """The function executed by the thread."""

        # --- Data Sanitization ---
        # Create a "clean" version of app_settings for the backend.
        # This ensures we only pass the voice ID to ElevenLabs, not the whole object.
        app_settings_clean = {
            "tts_provider": app_settings.get("tts_provider"),
            "speaker_voices": app_settings.get("speaker_voices", {})
        }

        # Nettoyage des voix Gemini: convertir "Name - Desc" -> "Name"
        gemini_clean = {}
        try:
            for speaker, voice in app_settings_clean.get("speaker_voices", {}).items():
                if isinstance(voice, str) and " - " in voice:
                    gemini_clean[speaker] = voice.split(" - ", 1)[0].strip()
                else:
                    gemini_clean[speaker] = voice
        except Exception:
            gemini_clean = app_settings_clean.get("speaker_voices", {})
        app_settings_clean["speaker_voices"] = gemini_clean

        elevenlabs_mapping_clean = {}
        elevenlabs_mapping_raw = app_settings.get("speaker_voices_elevenlabs", {})
        for speaker, data in elevenlabs_mapping_raw.items():
            if isinstance(data, dict):
                # New format: extract just the ID
                elevenlabs_mapping_clean[speaker] = data.get('id', '')
            else:
                # Legacy format: use the string as-is
                elevenlabs_mapping_clean[speaker] = data

        app_settings_clean["speaker_voices_elevenlabs"] = elevenlabs_mapping_clean
        # --- End of Data Sanitization ---

        generated_filepath = None
        try:
            self.logger.info("Starting generation thread.")
            self.log_status(f"Starting generation to '{os.path.basename(output_filepath)}'...")
            generated_filepath = self.generate_func(
                script_text=script_content,
                app_settings=app_settings_clean,  # Pass the clean version
                output_filepath=output_filepath,
                status_callback=self.log_status,
                api_key=api_key,
                parent_window=self.root
            )
            if generated_filepath:
                self.last_generated_filepath = generated_filepath
                self.logger.info(f"Generation completed successfully. File: {generated_filepath}")
                self.log_status(
                    f"\n--- Generation completed successfully! File: {os.path.basename(generated_filepath)} ---")
            else:
                self.logger.warning("Generation function completed without returning a file path.")
                self.log_status("\n--- Generation failed. Please check the logs. ---")
        except Exception as e:
            self.logger.error(f"Unhandled error in generation thread: {e}", exc_info=True)
            self.log_status(f"A critical error occurred in the thread: {e}")
            generated_filepath = None  # Ensure the status is 'failure'
        finally:
            # We use the queue, our reliable communication channel,
            # to signal the end of the generation and its status (success/failure).
            success = bool(generated_filepath)
            self.log_queue.put(('GENERATION_COMPLETE', success))

    def on_generation_complete(self, success: bool):
        if success:
            self.root.bell()
            if self.app_settings.get("tts_provider").lower() == "elevenlabs":
                self.update_elevenlabs_quota_in_status()

        self.progress_bar.stop()
        self._configure_button_state(self.generate_button, enabled=True)
        self._configure_button_state(self.load_button, enabled=True)
        self.menubar.entryconfig("Settings", state="normal") # pyright: ignore

        # Re-enable file-related buttons if a valid file exists, regardless of the last operation's success
        can_use_last_file = self.last_generated_filepath and os.path.exists(self.last_generated_filepath)

        self._configure_button_state(self.show_button, enabled=can_use_last_file)
        self._configure_button_state(self.play_button, enabled=(can_use_last_file and self.ffplay_path))

        can_generate_demo = self.is_whisperx_available and can_use_last_file
        self.actions_menu.entryconfig("Generate HTML Demo...", state='normal' if can_generate_demo else 'disabled')

        if self.progress_bar.winfo_ismapped():
            self.progress_bar.pack_forget()
        self.log_text.configure(state='disabled')  # Disable the log area at the very end

    def start_demo_generation_thread(self):
        """Opens a dialog to get demo settings, then starts the generation."""
        if not self.last_generated_filepath or not self.last_generated_script:
            messagebox.showwarning("No Data", "Please generate a podcast first before creating a demo.",
                                   parent=self.root)
            return

        # Create a default title from the audio filename
        base_name = os.path.splitext(os.path.basename(self.last_generated_filepath))[0]
        default_title = base_name.replace('_', ' ').replace('-', ' ').title()

        # Open the settings dialog and pass the callback
        DemoSettingsWindow(self.root, self._on_demo_settings_confirmed, default_title=default_title)

    def _on_demo_settings_confirmed(self, title: str, subtitle: str, output_dir: str):
        """Callback that receives settings from the dialog and starts the thread."""
        self.log_status("Starting HTML demo generation...")
        self.actions_menu.entryconfig("Generate HTML Demo...", state='disabled')

        thread = threading.Thread(
            target=self.run_demo_generation,
            args=(self.last_generated_script, self.last_generated_filepath, title, subtitle, output_dir)
        )
        thread.daemon = True
        thread.start()

    def run_demo_generation(self, script_content: str, audio_filepath: str, title: str, subtitle: str, output_dir: str):
        """The function executed by the demo generation thread."""
        temp_script_file = None
        try:
            # WhisperX requires a file, so we create a temporary one
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".txt", encoding='utf-8') as f:
                f.write(script_content)
                temp_script_file = f.name

            # Call the function from create_demo
            create_html_demo_whisperx(
                script_filepath=temp_script_file,
                audio_filepath=audio_filepath,
                title=title,
                subtitle=subtitle,
                output_dir=output_dir,
                status_callback=self.log_status
            )

        except Exception as e:
            self.logger.error(f"Error during demo generation: {e}", exc_info=True)
            self.log_status(f"An error occurred during demo generation: {e}")
        finally:
            # Re-enable the button on the main thread
            if self.root.winfo_exists():
                can_generate_demo = self.is_whisperx_available and self.last_generated_filepath and os.path.exists(self.last_generated_filepath)
                self.root.after(0, lambda: self.actions_menu.entryconfig("Generate HTML Demo...", state='normal' if can_generate_demo else 'disabled'))
            # Clean up the temporary file
            if temp_script_file and os.path.exists(temp_script_file):
                os.remove(temp_script_file)

    def open_file_location(self):
        """Opens the folder containing the last generated file and selects it."""
        if not self.last_generated_filepath or not os.path.exists(self.last_generated_filepath):
            messagebox.showerror("File not found", "The generated audio file was not found or is no longer accessible.")
            return

        try:
            if sys.platform == "darwin":  # macOS
                # 'open -R' reveals the file in Finder
                subprocess.run(["open", "-R", self.last_generated_filepath], check=True)
            elif sys.platform == "win32":  # Windows
                # For explorer.exe, it's more reliable to use shell=True and pass
                # the command as a string, with the path properly quoted.
                filepath = os.path.normpath(self.last_generated_filepath)
                subprocess.run(f'explorer /select,"{filepath}"', shell=True)
            else:  # Linux and others (opens the containing folder)
                subprocess.run(["xdg-open", os.path.dirname(self.last_generated_filepath)], check=True)
        except (FileNotFoundError, subprocess.CalledProcessError) as e:
            messagebox.showerror("Error", f"Unable to open the file manager.\n"
                                          f"Check that system tools are accessible.\n\nError: {e}")

    def play_last_generated_file(self):
        """Plays or stops the playback of the last generated audio file."""
        if self.playback_obj and self.playback_obj.poll() is None:
            self.playback_obj.terminate()  # Stops the ffplay process if running
            return

        if not self.ffplay_path:
            messagebox.showerror(
                "Audio player not found",
                "The 'ffplay' command (part of FFmpeg) was not found.\n\n"
                "Playback is disabled. Please ensure FFmpeg is properly installed."
            )
            self._configure_button_state(self.play_button, enabled=False)
            return

        if not self.last_generated_filepath or not os.path.exists(self.last_generated_filepath):
            messagebox.showerror("File not found", "The generated audio file was not found or is no longer accessible.")
            return

        threading.Thread(target=self._play_in_thread, daemon=True).start()

    def _play_in_thread(self):
        """The playback function executed in a separate thread."""
        try:
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW

            self.log_queue.put(('UPDATE_PLAY_BUTTON', '⏸', 'normal'))
            command = [self.ffplay_path, "-nodisp", "-autoexit", "-loglevel", "quiet", self.last_generated_filepath]
            self.playback_obj = subprocess.Popen(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                                 creationflags=creation_flags)
            self.playback_obj.wait()
        except Exception as e:
            self.logger.error(f"Audio playback error with ffplay: {e}", exc_info=True)
            self.log_status(f"Audio playback error: {e}")
        finally:
            self.playback_obj = None
            if self.root.winfo_exists():
                self.log_queue.put(('UPDATE_PLAY_BUTTON', '▶', 'normal'))

    def _reset_active_button(self):
        """Resets the currently active play button to its default state."""
        if self._active_play_button:
            try:
                if self._active_play_button.winfo_exists():
                    self._active_play_button.configure(text="▶")
            except (tk.TclError, AttributeError):
                pass  # Widget might have been destroyed
        self._active_play_button = None

    def play_gemini_voice_sample(self, button: customtkinter.CTkButton, voice_name: str):
        """Plays a voice sample for the given Gemini voice name."""
        sample_filename = f"{voice_name}.mp3"
        sample_path = get_asset_path(os.path.join("samples", "gemini_voices", sample_filename))

        if not sample_path:
            self.log_status(f"Sample for voice '{voice_name}' not found.")
            return
        self._play_sample(button, sample_path)

    def play_elevenlabs_voice_sample(self, button: customtkinter.CTkButton, voice_id: str, preview_url: str):
        """Plays a voice sample for ElevenLabs from a URL."""
        if not preview_url:
            self.log_status(f"No preview available for voice ID '{voice_id}'.")
            return
        self._play_sample(button, preview_url)

    def _stop_sample_playback(self):
        """Stops any active sample playback and resets associated UI elements."""
        if self.sample_poll_id:
            self.root.after_cancel(self.sample_poll_id)
            self.sample_poll_id = None

        if self.sample_playback_obj and self.sample_playback_obj.poll() is None:
            self.sample_playback_obj.terminate()
            self.sample_playback_obj = None
            self._reset_active_button()

    def _poll_sample_playback(self):
        """Periodically checks if the sample playback process has finished."""
        if self.sample_playback_obj:
            if self.sample_playback_obj.poll() is not None:  # Process has finished
                self.sample_playback_obj = None
                self._reset_active_button()
                if self.sample_poll_id:
                    self.root.after_cancel(self.sample_poll_id)
                    self.sample_poll_id = None
            else:  # Still playing, schedule next check
                self.sample_poll_id = self.root.after(250, self._poll_sample_playback)
        elif self.sample_poll_id:  # No process but polling is scheduled, so cancel it
            self.root.after_cancel(self.sample_poll_id)
            self.sample_poll_id = None

    def _play_sample(self, button: customtkinter.CTkButton, sample_source: str):
        """
        Plays a voice sample using a polling mechanism to update the UI,
        which is more robust than using a separate thread's finally block.
        """
        button_that_was_playing = self._active_play_button
        self._stop_sample_playback()

        # If the button we just clicked was the one playing, our only job was to stop it.
        if button_that_was_playing == button:
            return

        # --- Start new playback ---
        self._active_play_button = button
        try:
            if button.winfo_exists():
                button.configure(text="⏸")
        except (tk.TclError, AttributeError):
            self._reset_active_button()
            return

        if not self.ffplay_path:
            messagebox.showwarning("Player Not Found", "ffplay (part of FFmpeg) is required to play voice samples.",
                                   parent=self.root)
            self._reset_active_button()
            return

        try:
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW

            command = [self.ffplay_path, "-nodisp", "-autoexit", "-loglevel", "quiet", sample_source]
            self.sample_playback_obj = subprocess.Popen(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                                        creationflags=creation_flags)
            # Start polling for completion
            self._poll_sample_playback()
        except Exception as e:
            self.logger.error(f"Voice sample playback error: {e}", exc_info=True)
            self._reset_active_button()
            self.sample_playback_obj = None

    def on_settings_window_close(self):
        self._stop_sample_playback()
        self.menubar.entryconfig("Settings", state="normal")
        self._update_provider_label()
        self.provider_var.set(self.app_settings.get("tts_provider", "elevenlabs").lower())
        self.update_provider_menu_state()
        if self.app_settings.get("tts_provider", "").lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

    def _update_provider_label(self):
        """Updates the provider label based on the current provider and cached quota text."""
        current_provider_raw = self.app_settings.get("tts_provider", "elevenlabs")
        current_provider_display = current_provider_raw.title()
        text_to_display = f"TTS Provider: {current_provider_display}"

        # Si ElevenLabs est actif et qu’un quota est connu, afficher le quota
        if current_provider_raw.lower() == "elevenlabs" and self.elevenlabs_quota_text:
            text_to_display = self.elevenlabs_quota_text

        if hasattr(self, 'provider_label'):
            self.provider_label.configure(text=text_to_display)

    def _schedule_provider_label_refresh(self, delay_ms=2000, retries=5):
        """Planifie des rafraîchissements du provider_label après un délai, avec quelques tentatives."""

        def _try_refresh(attempt=1):
            # Met à jour le label avec l’info la plus récente disponible
            self._update_provider_label()
            # Si ElevenLabs est actif et que le quota n'est pas encore connu, retente plus tard
            if (
                    attempt < retries
                    and self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs"
                    and not self.elevenlabs_quota_text
            ):
                self.root.after(delay_ms, lambda: _try_refresh(attempt + 1))

        # Premier essai après delay_ms
        self.root.after(delay_ms, _try_refresh)

    def perform_startup_tasks(self):
        """
        Handles tasks that need to run after the main window is initialized,
        like checking for API keys and pre-fetching data.
        """
        # --- API key check at startup ---
        import keyring
        current_provider = self.app_settings.get("tts_provider", "elevenlabs")
        account_name = "elevenlabs_api_key" if current_provider == "elevenlabs" else "gemini_api_key"
        api_key = keyring.get_password("PodcastGenerator", account_name)

        if not api_key:
            # Open the API key management window and wait for it to close
            win = self.open_api_keys_window()
            self.root.deiconify()  # Ensure the parent window is visible for the dialog
            self.root.wait_window(win)

            # Re-check the key after the dialog is closed
            api_key = keyring.get_password("PodcastGenerator", account_name)
            if not api_key:
                self.logger.info("Application closed because no API key was provided at startup.")
                messagebox.showwarning("API Key Required", "The application cannot start without an API key.",
                                       parent=self.root)
                self.root.destroy()
                return False  # Indicate failure

        # Now that we have the key, assign it to the app and update the UI.
        self.api_key = api_key
        self.update_provider_menu_state()
        self.update_voice_settings_enabled()

        # --- Pre-fetch ElevenLabs voices ---
        def _prefetch_elevenlabs():
            """Prefetches ElevenLabs voices using the v1 API."""
            try:
                import keyring, requests
                key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
                if not key:
                    self.elevenlabs_voices_cache = []
                    return

                headers = {"xi-api-key": key}
                resp = requests.get("https://api.elevenlabs.io/v1/voices", headers=headers, timeout=15)

                if resp.status_code != 200:
                    self.elevenlabs_voices_cache = []
                    return

                data = resp.json()
                voices = []
                for voice in data.get('voices', []):
                    labels = voice.get('labels', {}) if voice.get('labels') else {}
                    desc_parts = [p.title() for p in [labels.get('gender'), labels.get('age'), labels.get('accent')] if p]
                    description = ', '.join(desc_parts) or str(voice.get('category', '')).title()
                    display_name = f"{voice.get('name', 'Unknown')} - {description}" if description else voice.get('name', 'Unknown')
                    voices.append({'id': voice.get('voice_id', ''), 'name': voice.get('name', 'Unknown'),
                                   'display_name': display_name, 'category': voice.get('category', ''),
                                   'labels': labels, 'preview_url': voice.get('preview_url', '')})
                voices.sort(key=lambda x: x.get('name', ''))
                self.elevenlabs_voices_cache = voices
            except Exception:
                self.elevenlabs_voices_cache = []

        threading.Thread(target=_prefetch_elevenlabs, daemon=True).start()
        return True  # Indicate success

class DemoSettingsWindow(customtkinter.CTkToplevel):
    def __init__(self, parent, callback, default_title=""):
        super().__init__(parent)
        self.title("HTML Demo Settings")
        self.transient(parent)
        self.grab_set()
        self.resizable(False, False)
        self.callback = callback

        main_frame = customtkinter.CTkFrame(self, fg_color="transparent")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- Fields ---
        fields_frame = customtkinter.CTkFrame(main_frame, fg_color="transparent")
        fields_frame.pack(fill=tk.X, padx=20, pady=15)

        # Title
        customtkinter.CTkLabel(fields_frame, text="Title:").grid(row=0, column=0, sticky="w", pady=2)
        self.title_var = tk.StringVar(value=default_title)
        self.title_entry = customtkinter.CTkEntry(fields_frame, textvariable=self.title_var, width=350)
        self.title_entry.grid(row=0, column=1, sticky="ew", pady=2, padx=5)

        # Subtitle
        customtkinter.CTkLabel(fields_frame, text="Subtitle:").grid(row=1, column=0, sticky="w", pady=2)
        self.subtitle_var = tk.StringVar()
        self.subtitle_entry = customtkinter.CTkEntry(fields_frame, textvariable=self.subtitle_var, width=350)
        self.subtitle_entry.grid(row=1, column=1, sticky="ew", pady=2, padx=5)

        # Output Directory
        customtkinter.CTkLabel(fields_frame, text="Output Directory:").grid(row=2, column=0, sticky="w", pady=2)
        self.output_dir_var = tk.StringVar(value=os.path.expanduser("~/Downloads"))
        dir_frame = customtkinter.CTkFrame(fields_frame, fg_color="transparent")
        dir_frame.grid(row=2, column=1, sticky="ew", pady=2, padx=5)
        self.output_dir_entry = customtkinter.CTkEntry(dir_frame, textvariable=self.output_dir_var)
        self.output_dir_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)

        browse_button = customtkinter.CTkButton(dir_frame, text="Browse...", command=self.browse_directory, width=80)
        browse_button.pack(side=tk.LEFT, padx=(5, 0))

        fields_frame.grid_columnconfigure(1, weight=1)

        # --- Buttons ---
        button_frame = customtkinter.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack(pady=(15, 15))

        ok_button = customtkinter.CTkButton(button_frame, text="Generate Demo", command=self.on_ok)

        ok_button.pack(side=tk.LEFT, padx=5)
        cancel_button = customtkinter.CTkButton(button_frame, text="Cancel", command=self.destroy,
                                                fg_color="transparent", text_color = ("gray10", "gray90"), border_width=1)

        cancel_button.pack(side=tk.LEFT, padx=5)

        self.protocol("WM_DELETE_WINDOW", self.destroy)
        self.bind('<Return>', lambda event: ok_button.invoke())
        self.bind('<Escape>', lambda event: cancel_button.invoke())

        self.after(100, self.title_entry.focus_set)

    def browse_directory(self):
        directory = filedialog.askdirectory(
            title="Select Output Directory",
            initialdir=self.output_dir_var.get(),
            parent=self
        )
        if directory:
            self.output_dir_var.set(directory)

    def on_ok(self):
        title = self.title_var.get().strip()
        subtitle = self.subtitle_var.get().strip()
        output_dir = self.output_dir_var.get().strip()

        if not title:
            messagebox.showerror("Validation Error", "Title cannot be empty.", parent=self)
            return
        if not output_dir:
            messagebox.showerror("Validation Error", "Output directory cannot be empty.", parent=self)
            return

        self.callback(title, subtitle, output_dir)
        self.destroy()

def main():
    # Initializes the application and starts the main Tkinter loop
    # Creates the root window but hides it for now.
    # This allows for reliable display of error dialogs
    # even if the full interface initialization fails.

    root = customtkinter.CTk()
    root.withdraw()

    # --- Import path correction ---
    # Ensures the script can find 'generate_podcast.py'
    # regardless of where it is executed from.
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        if script_dir not in sys.path:
            sys.path.insert(0, script_dir)
    except NameError:
        # __file__ is not defined in some interactive environments
        pass

    # --- Importing dependencies ---
    try:
        from generate_podcast import generate, PODCAST_SCRIPT, setup_logging, find_ffplay_path
        # Note: on n'importe plus get_api_key ici pour remplacer la saisie par la fenêtre de gestion des clés.
    except ImportError as e:
        messagebox.showerror(
            "Import Error",
            f"The file 'generate_podcast.py' was not found.\n\n"
            f"Please ensure it is in the same folder as gui.py.\n\n"
            f"Error details: {e}"
            , parent=root)
        root.destroy()
        return

    # Initializes logging before anything else
    logger = setup_logging()
    logger.info("Starting application...")

    # Create the app instance first, which populates the root window with widgets.
    # The window remains hidden for now. We pass a placeholder for the api_key.
    app = PodcastGeneratorApp(root, generate_func=generate, logger=logger, api_key="", default_script=PODCAST_SCRIPT)

    # Perform startup tasks (API key check, pre-fetching, etc.)
    if app.perform_startup_tasks():
        # If startup is successful, show the main window and start the event loop
        root.deiconify()
        root.mainloop()


if __name__ == "__main__":
    # This is crucial for preventing infinite loops when the app is frozen
    # with PyInstaller on macOS and Windows. It must be the first call
    # in the main block.
    import multiprocessing

    multiprocessing.freeze_support()
    main()