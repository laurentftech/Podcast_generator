import tkinter as tk
import tkinter.font as tkFont
from tkinter import filedialog, messagebox
import threading
import os
import subprocess
import sys
import queue
import json
import importlib.util
import webbrowser
import tempfile
from datetime import datetime, timezone
from typing import Optional

import keyring
import customtkinter
from CTkMenuBarPlus import CTkMenuBar

from demo_window import DemoSettingsWindow

try:
    import requests
except ImportError:
    requests = None

try:
    import CTkMenuBarPlus as CTkMenuBar
    if sys.platform != "darwin":
        HAS_CTK_MENUBAR = True
    else:
        HAS_CTK_MENUBAR = False
        CTkMenuBar = None
except ImportError:
    HAS_CTK_MENUBAR = False
    CTkMenuBar = None

from about_window import AboutWindow
from api_keys_window import APIKeysWindow
from generate_podcast import validate_speakers, update_elevenlabs_quota
from utils import get_asset_path, sanitize_app_settings_for_backend, find_ffplay_path, get_app_data_dir, sanitize_text
from create_demo import create_html_demo_whisperx
from config import AVAILABLE_VOICES, DEFAULT_APP_SETTINGS, DEMO_AVAILABLE

# --- Versioning ---
# This file is automatically generated by setuptools-scm
try:
    from _version import __version__  # type: ignore
except Exception:
    # Fallback développement: quand _version.py n'est pas encore généré
    __version__ = "0.0.0-dev"


def get_app_version() -> str:
    """Gets the application version from the _version.py file."""
    return __version__


class PodcastGeneratorApp:
    DEFAULT_APP_SETTINGS = {
        "tts_provider": "elevenlabs",
        "speaker_voices": {"John": "Schedar - Even", "Samantha": "Zephyr - Bright"},
        "speaker_voices_elevenlabs": {
            "John": {"id": "TX3LPaxmHKxFdv7VOQHJ", "display_name": "Liam - Male, Young, american"},
            "Samantha": {"id": "cgSgspJ2msm6clMCkdW9", "display_name": "Jessica - Female, Young, american"}
        },
        "elevenlabs_quota_cache": None
    }

    def __init__(self, root: tk.Tk, generate_func, logger, api_key: str, default_script: str = ""):
        self.root = root
        self.logger = logger
        self.root.title(f"Podcast Generator v{get_app_version()}")
        self.root.geometry("960x700")

        # --- customtkinter Theme and Appearance ---
        customtkinter.set_appearance_mode("dark" if self._is_system_dark_mode() else "light")
        customtkinter.set_default_color_theme("blue")

        # --- Application Icon ---
        icon_path = get_asset_path("podcast.png")
        if icon_path:
            try:
                img = tk.PhotoImage(file=icon_path)
                self.root.tk.call('wm', 'iconphoto', self.root._w, img)
            except tk.TclError:  # In case of format error, continue without icon
                self.logger.warning("Could not set application icon.")

        self.app_data_dir = get_app_data_dir()
        self.settings_filepath = os.path.join(self.app_data_dir, "settings.json")

        self.generate_func = generate_func
        self.api_key = api_key
        self.log_queue = queue.Queue()
        self.playback_obj = None  # To keep a reference to the playback process
        self.sample_playback_obj = None  # For voice sample playback
        self._active_play_button: Optional[customtkinter.CTkButton] = None
        self.sample_poll_id = None  # For polling playback status
        self.last_generated_filepath = None
        self.last_generated_script = None  # To store script for demo generation
        self.ffplay_path = find_ffplay_path()
        self.is_whisperx_available = self.check_whisperx_availability()
        self.elevenlabs_quota_text = None  # New state variable
        self.demo_available = DEMO_AVAILABLE # Read environment variable

        self.app_settings = self.load_settings()
        self.provider_var = tk.StringVar(value=self.app_settings.get("tts_provider", "elevenlabs").lower())

        # Initialiser les références de menu
        self.menu_bar = None
        self.settings_menu = None
        self.actions_menu = None
        self.help_menu = None
        self.tts_submenu = None
        self.menubar = None  # Pour le fallback Tkinter

        self._setup_menu()
        self._setup_widgets(default_script)

        if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

        # Cache des voix ElevenLabs préchargées
        self.elevenlabs_voices_cache = []

        self.poll_log_queue()

        # Update UI states after all widgets are created
        self.update_provider_menu_state()
        self.update_voice_settings_enabled()

        # Schedule initial quota fetch with longer delay on macOS ARM
        if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
            # Increase delay on macOS ARM to avoid blocking UI initialization
            delay = 3000 if sys.platform == "darwin" else 2000
            self._schedule_provider_label_refresh(delay_ms=delay, retries=5)

        # Démarrer le watcher seulement si on utilise les menus Tkinter, avec intervalle plus long sur macOS
        if not HAS_CTK_MENUBAR:
            # Use longer interval on macOS to reduce event loop interference
            interval = 5000 if sys.platform == "darwin" else 2000
            self._start_theme_watcher(interval_ms=interval)

        # Schedule the pre-fetch of voices with longer delay on macOS ARM to avoid startup race conditions
        prefetch_delay = 1500 if sys.platform == "darwin" else 500
        self.root.after(prefetch_delay, self._prefetch_elevenlabs_voices)

        self.logger.info("Main interface initialized.")

    def check_whisperx_availability(self) -> bool:
        """Checks if WhisperX can be imported without actually loading it."""
        # Using find_spec is safer for packaged apps as it doesn't load the
        # (potentially heavy and problematic) library just for a check.
        spec = importlib.util.find_spec("whisperx")
        if spec is None:
            self.logger.warning("WhisperX library not found. Demo generation will be disabled.")
            return False
        else:
            self.logger.info("WhisperX installation found. Demo generation is enabled.")
            return True

    def _get_menu_colors(self):
        """Retourne les couleurs du menu selon le thème actuel, synchronisées avec le fond principal."""
        appearance_mode = customtkinter.get_appearance_mode().lower()

        # Récupérer la couleur de fond de la fenêtre principale
        try:
            bg_color = self.root.cget("bg")  # couleur définie par CustomTkinter
        except Exception:
            bg_color = "#2b2b2b" if appearance_mode == "dark" else "#f0f0f0"

        if appearance_mode == "dark":
            return {
                'bg': bg_color,
                'fg': '#ffffff',
                'activebackground': '#404040',
                'activeforeground': '#ffffff',
                'selectcolor': '#1f538d',
                'disabledforeground': '#808080',
                'relief': 'flat',
                'borderwidth': 0
            }
        else:
            return {
                'bg': bg_color,
                'fg': '#000000',
                'activebackground': '#e0e0e0',
                'activeforeground': '#000000',
                'selectcolor': '#0078d4',
                'disabledforeground': '#808080'
            }

    def _apply_menu_theme(self, menu):
        """Applique le thème à un menu donné."""
        colors = self._get_menu_colors()
        menu.configure(**colors)

        # Forcer une police lisible pour les menus
        try:
            default_font = tkFont.nametofont('TkMenuFont')
            default_font.configure(size=11)
            menu.configure(font=default_font)
        except Exception:
            pass

    def _setup_menu(self):
        """Sets up the main application menu bar with CTkMenuBarPlus or fallback to Tkinter."""
        if HAS_CTK_MENUBAR:
            self._setup_ctk_menu()
        else:
            self._setup_tkinter_menu()

    def _setup_ctk_menu(self):
        """Configure le menu avec CTkMenuBarPlus."""
        # Créer la barre de menu principale
        self.menu_bar = CTkMenuBar.CTkMenuBar(self.root, bg_color=customtkinter.ThemeManager.theme["CTkToplevel"]["fg_color"])

        # Menu Settings
        settings_button = self.menu_bar.add_cascade("Settings")
        self.settings_menu = CTkMenuBar.CustomDropdownMenu(
            widget=settings_button,
            corner_radius=3,
            border_width=1,
            border_color=("gray70", "gray25")
        )

        # Voice settings
        self.voice_settings_item = self.settings_menu.add_option("Voice settings...",
                                                                 command=self.open_settings_window)

        self.settings_menu.add_separator()

        # TTS Provider (sera reconstruit dynamiquement)
        self.tts_menu_item = None
        self.rebuild_tts_provider_menu_ctk()

        # Manage API Keys
        self.settings_menu.add_option("Manage API Keys...", command=self.open_api_keys_window)

        # Quit (Windows/Linux seulement)
        if sys.platform != "darwin":
            self.settings_menu.add_separator()
            self.settings_menu.add_option("Quit", command=self.root.quit)

        # Menu Actions
        if self.demo_available:
            actions_button = self.menu_bar.add_cascade("Actions")
            self.actions_menu = CTkMenuBar.CustomDropdownMenu(
                widget=actions_button,
                corner_radius=3,
                border_width=1,
                border_color=("gray70", "gray25")
            )
            self.demo_menu_item = self.actions_menu.add_option("Generate HTML Demo...",
                                                               command=self.start_demo_generation_thread,
                                                               state='disabled')

        # Menu Help
        help_button = self.menu_bar.add_cascade("Help")
        self.help_menu = CTkMenuBar.CustomDropdownMenu(
            widget=help_button,
            corner_radius=3,
            border_width=1,
            border_color=("gray70", "gray25")
        )
        self.help_menu.add_option("Documentation (Github)...", command=self.open_documentation)
        self.help_menu.add_option("About...", command=self.show_about_window)

    def _setup_tkinter_menu(self):
        """Fallback vers le menu Tkinter classique avec thème amélioré."""
        self.menubar = tk.Menu(self.root)
        self.root.config(menu=self.menubar)

        # Appliquer le thème au menu principal
        self._apply_menu_theme(self.menubar)

        if sys.platform == "darwin":  # macOS
            try:
                # Create the special "app" menu. This can fail on non-native Tcl/Tk.
                app_menu = tk.Menu(self.menubar, name='apple', tearoff=0)
                self._apply_menu_theme(app_menu)
                self.menubar.add_cascade(label="Podcast Generator", menu=app_menu)

                app_menu.add_command(label=f"About Podcast Generator", command=self.show_about_window)
                app_menu.add_separator()
                app_menu.add_command(label="Voice settings...", command=self.open_settings_window,
                                     accelerator="Command+,")
                app_menu.add_separator()
                # Add standard macOS services for a native feel
                app_menu.add_command(label="Services", role="services")
                app_menu.add_separator()
                app_menu.add_command(label="Hide Podcast Generator", accelerator="Command+H", role="hide")
                app_menu.add_command(label="Hide Others", accelerator="Command+Option+H", role="hideothers")
                app_menu.add_command(label="Show All", role="unhide")
                app_menu.add_separator()
                app_menu.add_command(label="Quit Podcast Generator", accelerator="Command+Q", role="quit")
            except tk.TclError:
                # Fallback for older Tcl/Tk. Clear any partially created menu.
                self.menubar.delete(0, 'end')

        # Création du menu Settings (commun à toutes les plateformes)
        self.settings_menu = tk.Menu(self.menubar, tearoff=0)
        self._apply_menu_theme(self.settings_menu)
        self.menubar.add_cascade(label="Settings", menu=self.settings_menu)

        # Sous-menu TTS provider (n'apparaît que si 2 clés sont présentes)
        self.tts_submenu = None
        self.rebuild_tts_provider_menu()

        # Quit (pour Windows/Linux; sur macOS l'app menu expose déjà Quit)
        if sys.platform != "darwin":
            self.settings_menu.add_separator()
            self.settings_menu.add_command(label="Quit", command=self.root.quit)

        # --- Actions Menu ---
        if self.demo_available:
            self.actions_menu = tk.Menu(self.menubar, tearoff=0)
            self._apply_menu_theme(self.actions_menu)
            self.menubar.add_cascade(label="Actions", menu=self.actions_menu)
            self.actions_menu.add_command(label="Generate HTML Demo...",
                                          command=self.start_demo_generation_thread,
                                          state='disabled')

        # Help Menu (common to all platforms)
        self.help_menu = tk.Menu(self.menubar, tearoff=0)
        self._apply_menu_theme(self.help_menu)
        self.menubar.add_cascade(label="Help", menu=self.help_menu)
        self.help_menu.add_command(label="Documentation (Github)...", command=self.open_documentation)
        self.help_menu.add_command(label="About...", command=self.show_about_window)

    def rebuild_tts_provider_menu_ctk(self):
        """Reconstruit le menu TTS provider avec CTkMenuBarPlus."""
        import keyring

        gemini_key_exists = bool(keyring.get_password("PodcastGenerator", "gemini_api_key"))
        elevenlabs_key_exists = bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))
        both_keys = gemini_key_exists and elevenlabs_key_exists

        # Supprimer l'ancien item TTS si il existe
        if self.tts_menu_item and hasattr(self.settings_menu, 'delete_option'):
            try:
                self.settings_menu.delete_option(self.tts_menu_item)
            except:
                pass

        if both_keys:
            # Créer un sous-menu TTS provider
            self.tts_submenu = CTkMenuBar.CustomDropdownMenu(
                corner_radius=3,
                border_width=1,
                border_color=("gray70", "gray25")
            )

            # Ajouter les options
            current_provider = self.app_settings.get("tts_provider", "elevenlabs")
            self.tts_submenu.add_option("Gemini",
                                        command=lambda: self._select_provider("gemini"))
            self.tts_submenu.add_option("ElevenLabs",
                                        command=lambda: self._select_provider("elevenlabs"))

            # Ajouter le sous-menu au menu principal
            self.tts_menu_item = self.settings_menu.add_cascade("TTS provider", submenu=self.tts_submenu)

    def _select_provider(self, provider):
        """Gère la sélection du provider depuis CTkMenuBarPlus."""
        self.provider_var.set(provider)
        self.on_provider_selected()

    def update_voice_settings_enabled_ctk(self):
        """Met à jour l'état de Voice settings avec CTkMenuBarPlus."""
        import keyring
        has_any_key = bool(keyring.get_password("PodcastGenerator", "gemini_api_key")) or \
                      bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))

        try:
            if hasattr(self.settings_menu, 'configure_option') and self.voice_settings_item:
                state = 'normal' if has_any_key else 'disabled'
                self.settings_menu.configure_option(self.voice_settings_item, state=state)
        except:
            pass

        # Protéger l'accès au bouton si l'initialisation n'est pas terminée.
        if hasattr(self, "generate_button") and self.generate_button:
            self._configure_button_state(self.generate_button, enabled=has_any_key)

    def update_demo_menu_state_ctk(self, enabled):
        """Met à jour l'état du menu demo avec CTkMenuBarPlus."""
        if not self.demo_available:
            return
        try:
            if hasattr(self.actions_menu, 'configure_option') and self.demo_menu_item:
                state = 'normal' if enabled else 'disabled'
                self.actions_menu.configure_option(self.demo_menu_item, state=state)
        except:
            pass

    def _setup_widgets(self, default_script: str):
        # --- Root container (pack at root level only) ---
        container = customtkinter.CTkFrame(self.root, fg_color="transparent")
        container.pack(fill="both", expand=True)  # Use pack only for the container
        container.grid_columnconfigure(0, weight=1)
        container.grid_rowconfigure(0, weight=1)

        # --- Main Frame inside the container ---
        main_frame = customtkinter.CTkFrame(container, fg_color="transparent")
        main_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)

        main_frame.grid_columnconfigure(0, weight=1)
        main_frame.grid_rowconfigure(2, weight=1)  # Make script_text expand
        main_frame.grid_rowconfigure(4, weight=1)  # Make log_text expand

        # --- TTS Provider Status Bar ---
        status_frame = customtkinter.CTkFrame(main_frame, corner_radius=6, border_width=1)
        status_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))

        current_provider = self.app_settings.get("tts_provider", "elevenlabs").title()
        self.provider_label = customtkinter.CTkLabel(status_frame, text=f"TTS Provider: {current_provider}",
                                                     font=customtkinter.CTkFont(size=12))
        self.provider_label.pack(side=tk.LEFT, padx=10, pady=5)
        # Déclenche le rafraîchissement du quota immédiatement si ElevenLabs est actif
        if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
            self._load_cached_quota()
            self.update_elevenlabs_quota_in_status()

        # --- Script Text Area ---
        customtkinter.CTkLabel(main_frame, text="Script to read").grid(row=1, column=0, sticky="w", padx=5)
        self.script_text = customtkinter.CTkTextbox(main_frame, wrap=tk.WORD, border_width=1)
        self.script_text.grid(row=2, column=0, sticky="nsew", pady=(0, 10))
        self.script_text.insert(tk.END, default_script)

        # --- Log/Status Area ---
        customtkinter.CTkLabel(main_frame, text="Generation status").grid(row=3, column=0, sticky="w", padx=5)
        self.log_text = customtkinter.CTkTextbox(main_frame, wrap=tk.WORD, state='disabled', border_width=1,
                                                 fg_color="transparent")
        self.log_text.grid(row=4, column=0, sticky="nsew")

        # --- Progress Bar Placeholder & Widget ---
        # This frame reserves space for the progress bar to avoid window resizing.
        progress_bar_height = 20
        self.progress_bar_placeholder = customtkinter.CTkFrame(main_frame, fg_color="transparent",
                                                               height=progress_bar_height)
        self.progress_bar_placeholder.grid(row=5, column=0, sticky="ew")
        # Prevent children from resizing the placeholder
        self.progress_bar_placeholder.pack_propagate(False)

        self.progress_bar = customtkinter.CTkProgressBar(self.progress_bar_placeholder, mode='indeterminate',
                                                         progress_color="#4CAF50")

        # --- Button Frame ---
        self.button_frame = customtkinter.CTkFrame(main_frame, fg_color="transparent")
        self.button_frame.grid(row=6, column=0, sticky="ew", pady=(10, 0))
        self.button_frame.grid_columnconfigure((0, 1, 2), weight=1)  # The 3 main buttons expand
        self.button_frame.grid_columnconfigure(3, weight=0)  # The play button has a fixed size

        # --- Buttons ---
        self.load_button = customtkinter.CTkButton(self.button_frame, text="Load a script (.txt)",
                                                   command=self.load_script_from_file)
        self.load_button.grid(row=0, column=0, sticky="ew", padx=(0, 5))

        self.generate_button = customtkinter.CTkButton(self.button_frame, text="Start generation",
                                                       command=self.start_generation_thread)
        self.generate_button.grid(row=0, column=1, sticky="ew", padx=5)

        self.show_button = customtkinter.CTkButton(self.button_frame, text="Open file location",
                                                   command=self.open_file_location)
        self.show_button.grid(row=0, column=2, sticky="ew", padx=5)
        self._configure_button_state(self.show_button, enabled=False)

        self.play_button = customtkinter.CTkButton(self.button_frame, text="▶",
                                                   command=self.play_last_generated_file, width=40)
        self.play_button.grid(row=0, column=3, sticky="e", padx=(5, 0))
        self._configure_button_state(self.play_button, enabled=False)

    def _load_cached_quota(self):
        """Loads and displays the cached quota if available."""
        cached = self.app_settings.get("elevenlabs_quota_cache") or {}
        cached_text = cached.get("text")
        if cached_text:
            self.elevenlabs_quota_text = cached_text
            self._update_provider_label()

    def _is_system_dark_mode(self) -> bool:
        """Retourne True si le système (macOS ou Windows) est en mode sombre."""
        try:
            if sys.platform == "darwin":
                # AppleInterfaceStyle existe seulement en mode sombre
                proc = subprocess.run(
                    ["defaults", "read", "-g", "AppleInterfaceStyle"],
                    capture_output=True, text=True
                )
                return proc.returncode == 0 and proc.stdout.strip().lower() == "dark"

            if sys.platform == "win32":
                import winreg
                key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,
                                     r'Software\Microsoft\Windows\CurrentVersion\Themes\Personalize')
                value, _ = winreg.QueryValueEx(key, 'AppsUseLightTheme')
                winreg.CloseKey(key)
                return value == 0
        except Exception:
            # En cas d'erreur (ex: clé de registre absente, commande non trouvée), on suppose le mode clair.
            return False
        return False  # Pour les autres OS (Linux, etc.)

    def _start_theme_watcher(self, interval_ms: int = 2000):
        """Surveille le mode sombre (macOS/Windows) et met à jour le thème de l'application si l'état change."""

        def _tick():
            try:
                current = self._is_system_dark_mode()
                current_app_mode = customtkinter.get_appearance_mode().lower()
                if (current and current_app_mode != "dark") or (not current and current_app_mode != "light"):
                    customtkinter.set_appearance_mode("dark" if current else "light")
                    # Mettre à jour les couleurs du menu quand le thème change
                    self._update_all_menu_themes()
            finally:
                # Replanifie la prochaine vérification
                if self.root and self.root.winfo_exists():
                    self.root.after(interval_ms, _tick)

        # Premier tick
        if self.root and self.root.winfo_exists():
            self.root.after(interval_ms, _tick)

    def _update_all_menu_themes(self):
        """Met à jour le thème de tous les menus existants."""
        # Seulement pour les menus Tkinter classiques
        if HAS_CTK_MENUBAR:
            return

        try:
            # Menu principal
            if hasattr(self, 'menubar') and self.menubar:
                self._apply_menu_theme(self.menubar)

            # Sous-menus
            if hasattr(self, 'settings_menu') and self.settings_menu and not HAS_CTK_MENUBAR:
                self._apply_menu_theme(self.settings_menu)

            if hasattr(self, 'actions_menu') and self.actions_menu and not HAS_CTK_MENUBAR:
                self._apply_menu_theme(self.actions_menu)

            if hasattr(self, 'help_menu') and self.help_menu and not HAS_CTK_MENUBAR:
                self._apply_menu_theme(self.help_menu)

            if hasattr(self, 'tts_submenu') and self.tts_submenu and not HAS_CTK_MENUBAR:
                self._apply_menu_theme(self.tts_submenu)

        except Exception as e:
            # En cas d'erreur, on continue sans planter l'app
            if hasattr(self, 'logger'):
                self.logger.warning(f"Erreur lors de la mise à jour du thème des menus: {e}")

    def _configure_button_state(self, button: customtkinter.CTkButton, enabled: bool):
        """Configures the state and color of a button."""
        if not button:
            return

        try:
            if not button.winfo_exists():
                return
        except (tk.TclError, AttributeError):
            return

        try:
            if enabled:
                # Restore default theme color for the enabled state
                normal_fg_color = customtkinter.ThemeManager.theme["CTkButton"]["fg_color"]
                normal_text_color = customtkinter.ThemeManager.theme["CTkButton"]["text_color"]
                button.configure(state='normal', fg_color=normal_fg_color, text_color=normal_text_color)
            else:
                # Apply a custom, more opaque color for the disabled state
                disabled_fg_color = ("gray75", "gray30")
                # Use a readable text color for the disabled state
                disabled_text_color = ("gray10", "gray70")  # Dark gray for light mode, a less bright gray for dark mode
                button.configure(state='disabled', fg_color=disabled_fg_color, text_color_disabled=disabled_text_color)
        except (tk.TclError, AttributeError) as e:
            # Widget might be in an invalid state on macOS ARM
            self.logger.debug(f"Error configuring button state: {e}")

    def on_provider_selected(self):
        """Handles selection from the TTS Provider radio button menu."""
        new_provider = self.provider_var.get()
        # Prevent running the switch logic if the selection hasn't actually changed.
        # This can happen if the user cancels the API key dialog.
        if new_provider != self.app_settings.get("tts_provider"):
            self.switch_tts_provider(new_provider)

    def switch_tts_provider(self, provider: str):
        """Switch TTS provider, update settings, and fetch the correct API key."""
        if provider not in ["gemini", "elevenlabs"]:
            return

        from generate_podcast import get_api_key  # Local import is safe
        provider_title = "ElevenLabs v3" if provider == "elevenlabs" else provider.title()

        # Attempt to get the new API key from storage.
        # get_api_key will now return None immediately if the key is not in storage and we are in GUI mode.
        new_api_key = get_api_key(self.log_status, self.logger, parent_window=self.root, service=provider)

        # If the key is not found in storage, we need to ask the user.
        if not new_api_key:
            self.log_status(f"API key for {provider_title} not found in storage.")

            if messagebox.askyesno(
                    "API Key Required",
                    f"The API key for {provider_title} is not configured.\n\n"
                    f"Would you like to set it now?",
                    parent=self.root
            ):
                # Open the key management window and wait for it to close.
                keys_window = self.open_api_keys_window()
                self.root.wait_window(keys_window)

                # After the window is closed, try to get the key again from storage.
                new_api_key = get_api_key(self.log_status, self.logger, parent_window=self.root, service=provider)

        # If the key is still not available (user cancelled), abort the switch.
        if not new_api_key:
            self.log_status(f"API key acquisition for {provider_title} failed. Provider switch cancelled.")
            # Revert the radio button to the previous valid setting
            self.provider_var.set(self.app_settings.get("tts_provider", "elevenlabs"))
            return  # Do not show a warning, as the user has already interacted with a dialog.

        # If successful, update the API key in memory and in the settings.
        self.api_key = new_api_key
        self.app_settings["tts_provider"] = provider
        self.save_settings(self.app_settings)

        # Update UI to reflect the change
        self._update_provider_label()  # Update the label to its base state
        self.log_status(f"Successfully switched TTS provider to {provider_title}.")
        if provider == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

    def update_provider_menu_state(self):
        """
        Met à jour la disponibilité du sous-menu TTS provider en fonction des clés API.
        Le sous-menu n'apparaît que si les 2 clés sont configurées.
        """
        if HAS_CTK_MENUBAR:
            self.rebuild_tts_provider_menu_ctk()
            self.update_voice_settings_enabled_ctk()
        else:
            import keyring

            gemini_key_exists = bool(keyring.get_password("PodcastGenerator", "gemini_api_key"))
            elevenlabs_key_exists = bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))

            # (Re)construit le sous-menu dynamiquement
            self.rebuild_tts_provider_menu()

            # Mettre à jour l'état de "Voice settings..." (activé si au moins une clé)
            self.update_voice_settings_enabled()

    def rebuild_tts_provider_menu(self):
        """
        Reconstruit entièrement le menu 'Settings' dans l'ordre attendu avec le thème (Tkinter fallback).
        """
        if HAS_CTK_MENUBAR:
            return  # Cette méthode n'est utilisée que pour le fallback Tkinter

        import keyring, sys

        gemini_key_exists = bool(keyring.get_password("PodcastGenerator", "gemini_api_key"))
        elevenlabs_key_exists = bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))
        both_keys = gemini_key_exists and elevenlabs_key_exists
        has_any_key = gemini_key_exists or elevenlabs_key_exists

        # Vider et reconstruire le menu Settings dans l'ordre
        self.settings_menu.delete(0, 'end')

        # 1) Voice settings...
        self.settings_menu.add_command(
            label="Voice settings...",
            command=self.open_settings_window,
            state=('normal' if has_any_key else 'disabled')
        )

        # 2) Séparateur
        self.settings_menu.add_separator()

        # 3) TTS provider
        if both_keys:
            # Cascade avec flèche
            self.tts_submenu = tk.Menu(self.settings_menu, tearoff=0)
            self._apply_menu_theme(self.tts_submenu)  # Appliquer le thème au sous-menu
            self.tts_submenu.add_radiobutton(label="Gemini", variable=self.provider_var, value="gemini",
                                             command=self.on_provider_selected)
            self.tts_submenu.add_radiobutton(label="ElevenLabs", variable=self.provider_var, value="elevenlabs",
                                             command=self.on_provider_selected)
            self.settings_menu.add_cascade(label="TTS provider", menu=self.tts_submenu)

            # 4) Séparateur
            self.settings_menu.add_separator()
        else:
            # Entrée simple désactivée (pas de flèche)
            self.tts_submenu = None

        # 5) Manage API Keys...
        self.settings_menu.add_command(label="Manage API Keys...", command=self.open_api_keys_window)

        # 6) Quit (Windows/Linux uniquement, macOS a déjà Quit dans le menu application)
        if sys.platform != "darwin":
            self.settings_menu.add_separator()
            self.settings_menu.add_command(label="Quit", command=self.root.quit)

    def update_voice_settings_enabled(self):
        """Active 'Voice settings...' si au moins une clé API est configurée, sinon désactive (Tkinter fallback)."""
        if HAS_CTK_MENUBAR:
            return  # Cette méthode n'est utilisée que pour le fallback Tkinter

        import keyring
        has_any_key = bool(keyring.get_password("PodcastGenerator", "gemini_api_key")) or \
                      bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))
        idx = self._find_menu_index_by_label(self.settings_menu, "Voice settings...")
        if idx is not None:
            self.settings_menu.entryconfig(idx, state='normal' if has_any_key else 'disabled')
            # Protéger l'accès au bouton si l'initialisation n'est pas terminée.
            if hasattr(self, "generate_button") and self.generate_button:
                self._configure_button_state(self.generate_button, enabled=has_any_key)

    def _find_menu_index_by_label(self, menu: tk.Menu, label: str):
        """Retourne l'index d'une entrée de menu par son label, ou None si absent."""
        try:
            end_index = menu.index('end')
            if end_index is None:
                return None
            for i in range(end_index + 1):
                try:
                    if menu.entrycget(i, 'label') == label:
                        return i
                except tk.TclError:
                    continue
        except tk.TclError:
            return None
        return None

    def open_api_keys_window(self):
        """Opens the API keys management window."""
        # Désactiver le menu Settings pendant l'ouverture
        if HAS_CTK_MENUBAR:
            try:
                # Pour CTkMenuBarPlus, on peut désactiver le bouton
                if hasattr(self.menu_bar, 'configure'):
                    self.menu_bar.configure(state="disabled")
            except:
                pass
        else:
            self.menubar.entryconfig("Settings", state="disabled")

        win = APIKeysWindow(self.root, self.on_api_keys_window_close)
        return win

    def on_api_keys_window_close(self):
        """Callback to re-enable the TTS menu when API keys window is closed."""
        if HAS_CTK_MENUBAR:
            try:
                if hasattr(self.menu_bar, 'configure'):
                    self.menu_bar.configure(state="normal")
            except:
                pass
        else:
            self.menubar.entryconfig("Settings", state="normal")

        # Rebuild UI elements synchronously
        self.update_provider_menu_state()

        # Defer the network-intensive quota update.
        # This prevents starting a thread from within the `wait_window` context during startup,
        # which is a major cause of instability on Windows.
        def deferred_quota_update():
            # Re-check provider in case it changed
            if self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs":
                self.update_elevenlabs_quota_in_status()

        # Schedule the update to run after the current event processing is complete.
        self.root.after(50, deferred_quota_update)

    def load_settings(self):
        """Loads settings from the JSON file."""
        try:
            with open(self.settings_filepath, 'r') as f:
                settings = json.load(f)
                # Load the settings as they are, preserving the rich dictionary for ElevenLabs.
                # The data will be flattened only when needed (right before generation).
                tts_provider = settings.get("tts_provider", DEFAULT_APP_SETTINGS["tts_provider"])
                speaker_voices = settings.get("speaker_voices", DEFAULT_APP_SETTINGS["speaker_voices"].copy())
                speaker_voices_elevenlabs = settings.get("speaker_voices_elevenlabs",
                                                         DEFAULT_APP_SETTINGS["speaker_voices_elevenlabs"].copy())
                elevenlabs_quota_cache = settings.get("elevenlabs_quota_cache", None)

                return {
                    "tts_provider": tts_provider,
                    "speaker_voices": speaker_voices,
                    "speaker_voices_elevenlabs": speaker_voices_elevenlabs,
                    "elevenlabs_quota_cache": elevenlabs_quota_cache
                }
        except (FileNotFoundError, json.JSONDecodeError):
            # Returns default app settings if the file does not exist or is corrupt
            return json.loads(json.dumps(DEFAULT_APP_SETTINGS))

    def save_settings(self, settings_to_save):
        """Saves the settings to the JSON file."""
        self.app_settings = settings_to_save
        try:
            os.makedirs(self.app_data_dir, exist_ok=True)  # Ensures the directory exists
            with open(self.settings_filepath, 'w') as f:
                json.dump(self.app_settings, f, indent=4)
            # self.log_status("Settings saved successfully.")
        except (IOError, OSError) as e:
            # CRITICAL: Do not show a messagebox here. It can crash the app if called
            # during the startup phase while the main window is withdrawn.
            self.logger.error(f"CRITICAL: Failed to save settings: {e}")

    def update_elevenlabs_quota_in_status(self):
        """Fetches ElevenLabs quota in a background thread and updates the status label."""
        key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
        if not key:
            self.elevenlabs_quota_text = None
            # Clear cache if no key
            self.app_settings["elevenlabs_quota_cache"] = None
            self.save_settings(self.app_settings)
            self.root.after(0, self._update_provider_label)
            return

        def _save_quota_cache(text: str):
            try:
                self.app_settings["elevenlabs_quota_cache"] = {
                    "text": text,
                    "timestamp": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
                }
                self.save_settings(self.app_settings)
            except Exception:
                pass

        def fetch_and_update():
            if not requests:
                self.logger.error("'requests' library not found. Cannot fetch ElevenLabs quota.")
                self.elevenlabs_quota_text = "TTS Provider: ElevenLabs v3 - 'requests' missing"
                # Use try/except to ensure UI thread safety on macOS
                try:
                    if self.root and self.root.winfo_exists():
                        self.root.after(0, self._update_provider_label)
                except (tk.TclError, RuntimeError):
                    pass
                return
            try:
                # Use the new v3-compatible quota function
                quota_text = update_elevenlabs_quota(key, self.log_status)
                if quota_text:
                    self.elevenlabs_quota_text = quota_text
                    _save_quota_cache(quota_text)
                else:
                    self.elevenlabs_quota_text = "TTS Provider: ElevenLabs v3 - Quota unavailable"
                    _save_quota_cache(self.elevenlabs_quota_text)
            except Exception as e:
                self.logger.error(f"Error fetching ElevenLabs quota: {e}", exc_info=True)
                self.elevenlabs_quota_text = "TTS Provider: ElevenLabs v3 - Network error"
                _save_quota_cache(self.elevenlabs_quota_text)
            finally:
                # Always schedule the UI update from the main thread with safety check
                try:
                    if self.root and self.root.winfo_exists():
                        self.root.after(0, self._update_provider_label)
                except (tk.TclError, RuntimeError):
                    # Window may have been destroyed, ignore
                    pass

        threading.Thread(target=fetch_and_update, daemon=True).start()

    def open_settings_window(self):
        # Disable the button while the window is open to avoid duplicates
        if HAS_CTK_MENUBAR:
            try:
                if hasattr(self.menu_bar, 'configure'):
                    self.menu_bar.configure(state="disabled")
            except:
                pass
        else:
            self.menubar.entryconfig("Settings", state="disabled")

        # Always open the window immediately. VoiceSettingsWindow handles
        # asynchronous loading of ElevenLabs voices internally (see settings_window.py:110-111).
        self._show_settings_window()

    def _show_settings_window(self):
        """Creates and displays the actual settings window."""
        from settings_window import VoiceSettingsWindow
        VoiceSettingsWindow(
            self.root,
            current_settings=self.app_settings,
            save_callback=self.save_settings,
            close_callback=self.on_settings_window_close,
            default_settings=self.DEFAULT_APP_SETTINGS,
            preloaded_elevenlabs_voices=self.elevenlabs_voices_cache,
            play_gemini_sample_callback=self.play_gemini_voice_sample,
            play_elevenlabs_sample_callback=self.play_elevenlabs_voice_sample
        )

    def show_about_window(self):
        """Displays the 'About' window."""
        AboutWindow(self.root, version=get_app_version())

    def open_documentation(self):
        """Opens the link to the documentation or the repository."""
        webbrowser.open_new_tab("https://github.com/laurentftech/Podcast_generator")

    def log_status(self, message: str):
        self.log_queue.put(message)

    def poll_log_queue(self):
        # We only process one message at a time to avoid blocking the event loop.
        # This ensures the interface remains responsive and can handle other tasks
        # (like on_generation_complete) between log displays.
        try:
            message = self.log_queue.get_nowait()
            if isinstance(message, tuple):
                msg_type = message[0]
                if msg_type == 'GENERATION_COMPLETE':
                    self.on_generation_complete(success=message[1])
                elif msg_type == 'UPDATE_PLAY_BUTTON':
                    is_enabled = message[2] == 'normal'
                    self._configure_button_state(self.play_button, enabled=is_enabled)
                    try:
                        if self.play_button and self.play_button.winfo_exists():
                            self.play_button.configure(text=message[1])
                    except (tk.TclError, AttributeError):
                        pass  # Widget might be in an invalid state
            else:
                self._update_log(message)
        except queue.Empty:
            pass  # The queue is empty, do nothing
        except Exception as e:
            # Log but don't crash if there's an issue processing the queue
            self.logger.debug(f"Error processing log queue: {e}")

        # Schedule next poll, with safety check for window existence
        try:
            if self.root and self.root.winfo_exists():
                # Slightly longer interval on macOS to reduce event loop contention
                interval = 150 if sys.platform == "darwin" else 100
                self.root.after(interval, self.poll_log_queue)
        except (tk.TclError, RuntimeError):
            pass  # Window destroyed, stop polling

    def _update_log(self, message):
        self.log_text.configure(state='normal')
        self.log_text.insert(tk.END, message + "\n")
        self.log_text.see(tk.END)
        self.log_text.configure(state='disabled')

    def clear_log(self):
        """Clears the log text area."""
        self.log_text.configure(state='normal')
        self.log_text.delete('1.0', tk.END)
        self.log_text.configure(state='disabled')

    def load_script_from_file(self):
        """Opens a dialog to load a .txt file into the script area."""
        filepath = filedialog.askopenfilename(
            title="Open a script file",
            filetypes=(("Text files", "*.txt"), ("All files", "*.*")),
            parent=self.root
        )
        if not filepath:
            return

        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
                sanitized_content = sanitize_text(content)
                self.script_text.delete('1.0', tk.END)
                self.script_text.insert('1.0', sanitized_content)
            self.log_status(f"Script loaded and sanitized from: {os.path.basename(filepath)}")
        except Exception as e:
            messagebox.showerror("Reading error", f"Cannot read the file:\n{e}", parent=self.root)
            self.logger.error(f"Error reading the script: {e}")

    def start_generation_thread(self):
        """Starts the generation in a separate thread to avoid freezing the UI."""
        script_content = self.script_text.get("1.0", tk.END).strip()
        if not script_content:
            messagebox.showwarning("Empty script", "Please enter or load a script before starting generation.",
                                   parent=self.root)
            return

        # Sanitize the script content before using it
        sanitized_script = sanitize_text(script_content)
        self.last_generated_script = sanitized_script  # Store sanitized script for demo

        # --- Validate Speaker Voices ---
        try:
            missing_speakers, configured_speakers = validate_speakers(sanitized_script, self.app_settings)
        except ValueError as e:
            # Règle Gemini: plus de 2 speakers -> erreur bloquante
            messagebox.showerror("Configuration Error", str(e), parent=self.root)
            return

        if missing_speakers:
            missing_speakers_str = ", ".join(missing_speakers)
            configured_str = ", ".join(configured_speakers) if configured_speakers else "None"
            messagebox.showerror(
                "Configuration Error",
                f"The following speakers from the script do not have an assigned voice:\n\n"
                f"Missing speakers: {missing_speakers_str}\n\n"
                f"Configured speakers: {configured_str}\n\n"
                f"Please configure their voices in 'Options -> Voice Settings' before continuing.",
                parent=self.root
            )
            return

        # Ask the user where to save the output file
        output_filepath = filedialog.asksaveasfilename(
            title="Save podcast as...",
            defaultextension=".mp3",
            filetypes=(
                ("MP3", "*.mp3"),
                ("WAV", "*.wav"),
                ("All files", "*.*")
            ),
            initialdir=os.path.expanduser("~/Downloads"),
            parent=self.root
        )

        if not output_filepath:
            self.log_status("Generation cancelled by user.")
            return

        # Disable buttons during generation
        self._configure_button_state(self.generate_button, enabled=False)
        self._configure_button_state(self.load_button, enabled=False)
        self._configure_button_state(self.play_button, enabled=False)
        self._configure_button_state(self.show_button, enabled=False)

        # Désactiver les menus selon le type
        if HAS_CTK_MENUBAR:
            self.update_demo_menu_state_ctk(False)
            try:
                if hasattr(self.menu_bar, 'configure'):
                    self.menu_bar.configure(state="disabled")
            except:
                pass
        else:
            if self.demo_available:
                self.actions_menu.entryconfig("Generate HTML Demo...", state='disabled')
            self.menubar.entryconfig("Settings", state="disabled")

        # Show and start the progress bar
        self.clear_log()

        self.progress_bar.pack(pady=5, padx=5, fill='x', expand=True)
        self.progress_bar.start()

        thread = threading.Thread(
            target=self.run_generation,
            args=(sanitized_script, output_filepath, self.app_settings, self.api_key)
        )
        thread.daemon = True
        thread.start()

    def run_generation(self, script_content, output_filepath, app_settings, api_key):
        """The function executed by the thread."""

        # Sanitize settings for the backend using the centralized function
        app_settings_clean = sanitize_app_settings_for_backend(app_settings)

        generated_filepath = None
        try:
            self.logger.info("Starting generation thread.")
            self.log_status(f"Starting generation to '{os.path.basename(output_filepath)}'...")
            generated_filepath = self.generate_func(
                script_text=script_content,
                app_settings=app_settings_clean,  # Pass the clean version
                output_filepath=output_filepath,
                status_callback=self.log_status,
                api_key=api_key,
                parent_window=self.root
            )
            if generated_filepath:
                self.last_generated_filepath = generated_filepath
                self.logger.info(f"Generation completed successfully. File: {generated_filepath}")
                self.log_status(
                    f"\n--- Generation completed successfully! File: {os.path.basename(generated_filepath)} ---")
            else:
                self.logger.warning("Generation function completed without returning a file path.")
                self.log_status("\n--- Generation failed. Please check the logs. ---")
        except Exception as e:
            self.logger.error(f"Unhandled error in generation thread: {e}", exc_info=True)
            self.log_status(f"A critical error occurred in the thread: {e}")
            generated_filepath = None  # Ensure the status is 'failure'
        finally:
            # We use the queue, our reliable communication channel,
            # to signal the end of the generation and its status (success/failure).
            success = bool(generated_filepath)
            self.log_queue.put(('GENERATION_COMPLETE', success))

    def on_generation_complete(self, success: bool):
        if success:
            self.root.bell()
            if self.app_settings.get("tts_provider").lower() == "elevenlabs":
                self.update_elevenlabs_quota_in_status()

        self.progress_bar.stop()
        self._configure_button_state(self.generate_button, enabled=True)
        self._configure_button_state(self.load_button, enabled=True)

        # Réactiver les menus selon le type
        if HAS_CTK_MENUBAR:
            try:
                if hasattr(self.menu_bar, 'configure'):
                    self.menu_bar.configure(state="normal")
            except:
                pass
        else:
            self.menubar.entryconfig("Settings", state="normal")

        # Re-enable file-related buttons if a valid file exists, regardless of the last operation's success
        can_use_last_file = self.last_generated_filepath and os.path.exists(self.last_generated_filepath)

        self._configure_button_state(self.show_button, enabled=can_use_last_file)
        self._configure_button_state(self.play_button, enabled=(can_use_last_file and self.ffplay_path))

        can_generate_demo = self.is_whisperx_available and can_use_last_file
        if HAS_CTK_MENUBAR:
            self.update_demo_menu_state_ctk(can_generate_demo)
        else:
            if self.demo_available:
                self.actions_menu.entryconfig("Generate HTML Demo...", state='normal' if can_generate_demo else 'disabled')


        if self.progress_bar.winfo_ismapped():
            self.progress_bar.pack_forget()
        self.log_text.configure(state='disabled')  # Disable the log area at the very end

    def start_demo_generation_thread(self):
        """Opens a dialog to get demo settings, then starts the generation."""
        if not self.demo_available:
            return

        if not self.last_generated_filepath or not self.last_generated_script:
            messagebox.showwarning("No Data", "Please generate a podcast first before creating a demo.",
                                   parent=self.root)
            return

        # Create a default title from the audio filename
        base_name = os.path.splitext(os.path.basename(self.last_generated_filepath))[0]
        default_title = base_name.replace('_', ' ').replace('-', ' ').title()

        # Suggest a "demo" subdirectory in the same folder as the audio file
        default_output_dir = os.path.join(os.path.dirname(self.last_generated_filepath), "demo")

        # Open the settings dialog and pass the callback
        DemoSettingsWindow(self.root, self._on_demo_settings_confirmed, default_title=default_title,
                           default_output_dir=default_output_dir)

    def _on_demo_settings_confirmed(self, title: str, subtitle: str, output_dir: str):
        """Callback that receives settings from the dialog and starts the thread."""
        self.log_status("Starting HTML demo generation...")

        if HAS_CTK_MENUBAR:
            self.update_demo_menu_state_ctk(False)
        else:
            if self.demo_available:
                self.actions_menu.entryconfig("Generate HTML Demo...", state='disabled')

        thread = threading.Thread(
            target=self.run_demo_generation,
            args=(self.last_generated_script, self.last_generated_filepath, title, subtitle, output_dir)
        )
        thread.daemon = True
        thread.start()

    def run_demo_generation(self, script_content: str, audio_filepath: str, title: str, subtitle: str, output_dir: str):
        """The function executed by the demo generation thread."""
        temp_script_file = None
        try:
            # WhisperX requires a file, so we create a temporary one
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".txt", encoding='utf-8') as f:
                f.write(script_content)
                temp_script_file = f.name

            # Call the function from create_demo
            create_html_demo_whisperx(
                script_filepath=temp_script_file,
                audio_filepath=audio_filepath,
                title=title,
                subtitle=subtitle,
                output_dir=output_dir,
                status_callback=self.log_status
            )

        except Exception as e:
            self.logger.error(f"Error during demo generation: {e}", exc_info=True)
            self.log_status(f"An error occurred during demo generation: {e}")
        finally:
            # Re-enable the button on the main thread
            if self.root.winfo_exists():
                can_generate_demo = self.is_whisperx_available and self.last_generated_filepath and os.path.exists(
                    self.last_generated_filepath)

                if HAS_CTK_MENUBAR:
                    self.root.after(0, lambda: self.update_demo_menu_state_ctk(can_generate_demo))
                else:
                    if self.demo_available:
                        self.root.after(0, lambda: self.actions_menu.entryconfig("Generate HTML Demo...",
                                                                                 state='normal' if can_generate_demo else 'disabled'))
            # Clean up the temporary file
            if temp_script_file and os.path.exists(temp_script_file):
                os.remove(temp_script_file)

    def open_file_location(self):
        """Opens the folder containing the last generated file and selects it."""
        if not self.last_generated_filepath or not os.path.exists(self.last_generated_filepath):
            messagebox.showerror("File not found", "The generated audio file was not found or is no longer accessible.")
            return

        try:
            if sys.platform == "darwin":  # macOS
                # 'open -R' reveals the file in Finder
                subprocess.run(["open", "-R", self.last_generated_filepath], check=True)
            elif sys.platform == "win32":  # Windows
                # For explorer.exe, it's more reliable to use shell=True and pass
                # the command as a string, with the path properly quoted.
                filepath = os.path.normpath(self.last_generated_filepath)
                subprocess.run(f'explorer /select,"{filepath}"', shell=True)
            else:  # Linux and others (opens the containing folder)
                subprocess.run(["xdg-open", os.path.dirname(self.last_generated_filepath)], check=True)
        except (FileNotFoundError, subprocess.CalledProcessError) as e:
            messagebox.showerror("Error", f"Unable to open the file manager.\n"
                                          f"Check that system tools are accessible.\n\nError: {e}")

    def play_last_generated_file(self):
        """Plays or stops the playback of the last generated audio file."""
        if self.playback_obj and self.playback_obj.poll() is None: # If process exists and is running
            # Use a more robust stop mechanism to prevent race conditions, especially on Mac ARM.
            try:
                self.playback_obj.terminate()
                # The wait() call in the thread will handle the rest.
                # We don't need to wait here, just ensure the terminate signal is sent.
            except Exception as e:
                self.logger.error(f"Error terminating main playback: {e}")
            finally:
                # The thread's finally block will reset the button and object.
                pass
            return

        if not self.ffplay_path:
            messagebox.showerror(
                "Audio player not found",
                "The 'ffplay' command (part of FFmpeg) was not found.\n\n"
                "Playback is disabled. Please ensure FFmpeg is properly installed."
            )
            self._configure_button_state(self.play_button, enabled=False)
            return

        if not self.last_generated_filepath or not os.path.exists(self.last_generated_filepath):
            messagebox.showerror("File not found", "The generated audio file was not found or is no longer accessible.")
            return

        threading.Thread(target=self._play_in_thread, daemon=True).start()

    def _play_in_thread(self):
        """The playback function executed in a separate thread."""
        try:
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW

            self.log_queue.put(('UPDATE_PLAY_BUTTON', '⏸', 'normal'))
            command = [self.ffplay_path, "-nodisp", "-autoexit", "-loglevel", "quiet", self.last_generated_filepath]
            self.playback_obj = subprocess.Popen(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                                 creationflags=creation_flags)
            self.playback_obj.wait()
        except Exception as e:
            self.logger.error(f"Audio playback error with ffplay: {e}", exc_info=True)
            self.log_status(f"Audio playback error: {e}")
        finally:
            self.playback_obj = None
            # Check if window still exists before updating UI
            try:
                if self.root and self.root.winfo_exists():
                    self.log_queue.put(('UPDATE_PLAY_BUTTON', '▶', 'normal'))
            except (tk.TclError, RuntimeError):
                # Window destroyed, ignore
                pass

    def _reset_active_button(self):
        """Resets the currently active play button to its default state."""
        if self._active_play_button:
            try:
                if self._active_play_button.winfo_exists():
                    self._active_play_button.configure(text="▶")
            except (tk.TclError, AttributeError):
                pass  # Widget might have been destroyed
        self._active_play_button = None

    def play_gemini_voice_sample(self, button: customtkinter.CTkButton, voice_name: str):
        """Plays a voice sample for the given Gemini voice name."""
        sample_filename = f"{voice_name}.mp3"
        sample_path = get_asset_path(os.path.join("samples", "gemini_voices", sample_filename))

        if not sample_path:
            self.log_status(f"Sample for voice '{voice_name}' not found.")
            return
        self._play_sample(button, sample_path)

    def play_elevenlabs_voice_sample(self, button: customtkinter.CTkButton, voice_id: str, preview_url: str):
        """Plays a voice sample for ElevenLabs from a URL."""
        if not preview_url:
            self.log_status(f"No preview available for voice ID '{voice_id}'.")
            return
        self._play_sample(button, preview_url)

    def _stop_sample_playback(self):
        """Stops any active sample playback and resets associated UI elements."""
        if self.sample_poll_id:
            self.root.after_cancel(self.sample_poll_id)
            self.sample_poll_id = None

        if self.sample_playback_obj and self.sample_playback_obj.poll() is None:
            # Use wait() with a timeout for a more graceful shutdown, which is more
            # reliable on different architectures like Mac ARM.
            try:
                self.sample_playback_obj.terminate()  # Ask it to stop
                self.sample_playback_obj.wait(timeout=0.5)  # Wait for it to exit
            except subprocess.TimeoutExpired:
                self.sample_playback_obj.kill()  # Force kill if it doesn't respond
            finally:
                self.sample_playback_obj = None
            self._reset_active_button()

    def _poll_sample_playback(self):
        """Periodically checks if the sample playback process has finished."""
        if self.sample_playback_obj:
            if self.sample_playback_obj.poll() is not None:  # Process has finished
                self.sample_playback_obj = None
                self._reset_active_button()
                if self.sample_poll_id:
                    self.root.after_cancel(self.sample_poll_id)
                    self.sample_poll_id = None
            else:  # Still playing, schedule next check
                self.sample_poll_id = self.root.after(250, self._poll_sample_playback)
        elif self.sample_poll_id:  # No process but polling is scheduled, so cancel it
            self.root.after_cancel(self.sample_poll_id)
            self.sample_poll_id = None

    def _play_sample(self, button: customtkinter.CTkButton, sample_source: str):
        """
        Plays a voice sample using a polling mechanism to update the UI,
        which is more robust than using a separate thread's finally block.
        """
        button_that_was_playing = self._active_play_button
        self._stop_sample_playback()

        # If the button we just clicked was the one playing, our only job was to stop it.
        if button_that_was_playing == button:
            return

        # --- Start new playback ---
        self._active_play_button = button
        try:
            if button.winfo_exists():
                button.configure(text="⏸")
        except (tk.TclError, AttributeError):
            self._reset_active_button()
            return

        if not self.ffplay_path:
            messagebox.showwarning("Player Not Found", "ffplay (part of FFmpeg) is required to play voice samples.",
                                   parent=self.root)
            self._reset_active_button()
            return

        try:
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW

            command = [self.ffplay_path, "-nodisp", "-autoexit", "-loglevel", "quiet", sample_source]
            self.sample_playback_obj = subprocess.Popen(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                                        creationflags=creation_flags)
            # Start polling for completion
            self._poll_sample_playback()
        except Exception as e:
            self.logger.error(f"Voice sample playback error: {e}", exc_info=True)
            self._reset_active_button()
            self.sample_playback_obj = None

    def on_settings_window_close(self):
        self._stop_sample_playback()
        if HAS_CTK_MENUBAR:
            try:
                if hasattr(self.menu_bar, 'configure'):
                    self.menu_bar.configure(state="normal")
            except:
                pass
        else:
            self.menubar.entryconfig("Settings", state="normal")

        self._update_provider_label()
        self.provider_var.set(self.app_settings.get("tts_provider", "elevenlabs").lower())
        self.update_provider_menu_state()
        if self.app_settings.get("tts_provider", "").lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

    def _update_provider_label(self):
        """Updates the provider label based on the current provider and cached quota text."""
        current_provider_raw = self.app_settings.get("tts_provider", "elevenlabs")
        current_provider_display = current_provider_raw.title()
        text_to_display = f"TTS Provider: {current_provider_display}"

        # Si ElevenLabs est actif et qu'un quota est connu, afficher le quota
        if current_provider_raw.lower() == "elevenlabs" and self.elevenlabs_quota_text:
            text_to_display = self.elevenlabs_quota_text

        if hasattr(self, 'provider_label'):
            self.provider_label.configure(text=text_to_display)

    def _schedule_provider_label_refresh(self, delay_ms=2000, retries=5):
        """Planifie des rafraîchissements du provider_label après un délai, avec quelques tentatives."""

        def _try_refresh(attempt=1):
            # Met à jour le label avec l'info la plus récente disponible
            self._update_provider_label()
            # Si ElevenLabs est actif et que le quota n'est pas encore connu, retente plus tard
            if (
                    attempt < retries
                    and self.app_settings.get("tts_provider", "elevenlabs").lower() == "elevenlabs"
                    and not self.elevenlabs_quota_text
            ):
                self.root.after(delay_ms, lambda: _try_refresh(attempt + 1))

        # Premier essai après delay_ms
        self.root.after(delay_ms, _try_refresh)

    def perform_startup_tasks(self):
        """
        Handles tasks that need to run after the main window is initialized,
        like checking for API keys and pre-fetching data.
        """
        # --- API key check at startup ---
        # We need at least one key to start. Let's check both.
        gemini_key = keyring.get_password("PodcastGenerator", "gemini_api_key")
        elevenlabs_key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")

        if not gemini_key and not elevenlabs_key:
            # No keys at all. Force user to enter one.
            self.logger.info("No API keys found. Opening API key window at startup.")
            win = self.open_api_keys_window()
            self.root.wait_window(win)

            # Re-check the key after the dialog is closed
            gemini_key = keyring.get_password("PodcastGenerator", "gemini_api_key")
            elevenlabs_key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")

            if not gemini_key and not elevenlabs_key:
                self.logger.info("Application closed because no API key was provided at startup.")
                return False  # Indicate failure

        # --- Provider Auto-Correction Logic ---
        # If the stored provider's key is missing but another one exists, switch to it.
        # This is crucial for the first-launch scenario where the default is 'elevenlabs'
        # but the user only enters a Gemini key.
        current_provider = self.app_settings.get("tts_provider", "elevenlabs")
        if current_provider == "elevenlabs" and not elevenlabs_key and gemini_key:
            self.logger.info("ElevenLabs key not found, but Gemini key exists. Switching provider to Gemini.")
            self.app_settings["tts_provider"] = "gemini"
            self.save_settings(self.app_settings)
        elif current_provider == "gemini" and not gemini_key and elevenlabs_key:
            self.logger.info("Gemini key not found, but ElevenLabs key exists. Switching provider to ElevenLabs.")
            self.app_settings["tts_provider"] = "elevenlabs"
            self.save_settings(self.app_settings)

        # At this point, app_settings should be in a consistent state.
        # Now, we load the key for the (potentially newly-set) current provider.
        current_provider = self.app_settings.get("tts_provider", "elevenlabs")
        if current_provider == "elevenlabs":
            self.api_key = elevenlabs_key
        elif current_provider == "gemini":
            self.api_key = gemini_key

        # Final validation: if we still don't have a key for the selected provider, fail.
        if not self.api_key:
            self.logger.error(
                f"Startup task failed: No valid API key found for the selected provider ('{current_provider}').")
            return False
        # UI updates are now deferred until after the window is shown to improve stability on Windows.
        # The pre-fetch is now handled by an 'after' call in __init__ to avoid race conditions.
        return True  # Indicate success

    def _prefetch_elevenlabs_voices(self):
        """Prefetches ElevenLabs voices in a background thread.
        This is started with a delay to avoid startup race conditions on Windows and macOS."""

        def _run_fetch():
            try:
                if not requests:
                    self.logger.warning("'requests' library not found. Cannot pre-fetch ElevenLabs voices.")
                    self.elevenlabs_voices_cache = []
                    return

                key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
                if not key:
                    self.elevenlabs_voices_cache = []
                    return

                headers = {"xi-api-key": key}
                # Increase timeout on macOS ARM to avoid connection issues
                timeout = 20 if sys.platform == "darwin" else 15
                resp = requests.get("https://api.elevenlabs.io/v1/voices", headers=headers, timeout=timeout)

                if resp.status_code != 200:
                    self.elevenlabs_voices_cache = []
                    return

                data = resp.json()
                voices = []
                for voice in data.get('voices', []):
                    labels = voice.get('labels', {}) if voice.get('labels') else {}
                    # Build short description from labels (like Gemini format)
                    # Format: gender, age, accent, use_case (lowercase except accent)
                    gender = labels.get('gender', '')
                    age = labels.get('age', '').replace('_', ' ')
                    accent = labels.get('accent', '').title()  # Capitalize accent
                    use_case = labels.get('use_case', '').replace('_', ' ')

                    desc_parts = [p for p in [gender, age, accent, use_case] if p]
                    short_description = ', '.join(desc_parts) if desc_parts else str(voice.get('category', '')).title()

                    # Store the full API description separately
                    full_description = voice.get('description', '').strip()

                    display_name = f"{voice.get('name', 'Unknown')} ({short_description})" if short_description else voice.get('name', 'Unknown')
                    voices.append({'id': voice.get('voice_id', ''), 'name': voice.get('name', 'Unknown'),
                                   'display_name': display_name, 'category': voice.get('category', ''),
                                   'labels': labels, 'preview_url': voice.get('preview_url', ''),
                                   'description': full_description, 'short_description': short_description})
                voices.sort(key=lambda x: x.get('name', ''))
                self.elevenlabs_voices_cache = voices
                self.logger.info(f"Successfully pre-fetched {len(voices)} ElevenLabs voices.")
            except Exception as e:
                self.logger.warning(f"Failed to pre-fetch ElevenLabs voices: {e}")
                self.elevenlabs_voices_cache = []


def show_error_and_log(*args):
    """Global exception handler with improved debugging."""
    print(f"DEBUG: show_error_and_log called with {len(args)} args", flush=True)
    print(f"DEBUG: Exception args: {args}", flush=True)

    if len(args) >= 3:
        import traceback
        err_type, err_value, err_tb = args[:3]
        error_message = "".join(traceback.format_exception(err_type, err_value, err_tb))

        print(f"DEBUG: Full exception traceback:\n{error_message}", flush=True)

        # Log only, don't show messagebox or destroy window yet
        try:
            from generate_podcast import setup_logging
            logger = setup_logging()
            logger.critical(f"Unhandled exception occurred:\n{error_message}")
        except:
            pass

        # Only show error for serious exceptions, not KeyboardInterrupt
        if err_type != KeyboardInterrupt:
            print("DEBUG: Showing error messagebox...", flush=True)
            try:
                import tkinter as tk
                from tkinter import messagebox
                # Create a temporary root if needed
                temp_root = tk.Tk()
                temp_root.withdraw()

                result = messagebox.askyesno(
                    "Error Occurred",
                    f"An error occurred: {err_value}\n\n"
                    f"Do you want to close the application?\n\n"
                    f"(Click 'No' to continue running)",
                    parent=temp_root
                )
                if result:  # User clicked Yes
                    print("DEBUG: User chose to close application", flush=True)
                    temp_root.destroy()
                    sys.exit(1)
                else:
                    print("DEBUG: User chose to continue running", flush=True)
                temp_root.destroy()
            except Exception as e:
                print(f"DEBUG: Error showing messagebox: {e}", flush=True)
        else:
            print("DEBUG: KeyboardInterrupt detected", flush=True)
    else:
        print(f"DEBUG: Unexpected args format: {args}", flush=True)


def debug_tk_error(*args):
    """Tkinter callback exception handler."""
    if len(args) >= 2:
        error = args[1]
        # Ignorer les erreurs de destruction d'app
        if "application has been destroyed" in str(error) or "invalid command name" in str(error):
            return

    try:
        show_error_and_log(*args)
    except:
        pass


def main():
    """Initializes the application, sets up error handling, and starts the main loop."""
    root = customtkinter.CTk()
    #root.withdraw()

    # --- DPI Scaling for Windows ---
    if sys.platform == 'win32':
        try:
            root.tk.call('tk', 'scaling', 1.25)
        except Exception:
            pass

    # --- Import path correction ---
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        if script_dir not in sys.path:
            sys.path.insert(0, script_dir)
    except NameError:
        pass  # __file__ is not defined in some interactive environments

    # --- Importing dependencies and setting up logging ---
    try:
        from generate_podcast import generate, PODCAST_SCRIPT, setup_logging
        logger = setup_logging()
    except ImportError as e:
        messagebox.showerror(
            "Import Error",
            f"The file 'generate_podcast.py' was not found.\n\n"
            f"Please ensure it is in the same folder as gui.py.\n\n"
            f"Error details: {e}",
            parent=root
        )
        root.destroy()
        return

    # --- Global Exception Handler ---
    sys.excepthook = show_error_and_log

    try:
        logger.info("Starting application...")

        # Create the app instance
        app = PodcastGeneratorApp(root, generate_func=generate, logger=logger, api_key="",
                                  default_script=PODCAST_SCRIPT)

        # Override the default tkinter error handler to use our global handler
        root.report_callback_exception = debug_tk_error

        # Perform startup tasks
        if app.perform_startup_tasks():
            def deferred_ui_updates():
                """
                This function runs after the mainloop has started, ensuring the UI is stable
                before these final configurations are applied. This is the key to preventing
                startup crashes on Windows.
                """
                # Vérifier que la fenêtre existe toujours
                if not root.winfo_exists():
                    return

                # Sync the UI variable with the final setting from startup tasks
                app.provider_var.set(app.app_settings.get("tts_provider", "elevenlabs"))

                # Update menu states now that the window is fully stable.
                app.update_provider_menu_state()
                if HAS_CTK_MENUBAR:
                    app.update_voice_settings_enabled_ctk()
                else:
                    app.update_voice_settings_enabled()

            root.mainloop()
        else:
            # This is a controlled exit, not a crash.
            messagebox.showerror("Startup Error", "The application cannot start. Please provide the required API keys.")
            root.destroy()

    except Exception:
        # This will catch errors during app instantiation or startup tasks
        # before the mainloop starts.
        show_error_and_log(*sys.exc_info())


if __name__ == "__main__":
    # This is crucial for preventing infinite loops when the app is frozen
    # with PyInstaller on macOS and Windows. It must be the first call
    # in the main block.
    import multiprocessing

    multiprocessing.freeze_support()
    main()