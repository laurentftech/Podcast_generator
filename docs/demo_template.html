<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{title}</title>
  <style>
    body {{ font-family: system-ui, sans-serif; max-width:800px; margin:2rem auto; line-height:1.6; }}
    h1 {{ margin-bottom: 0.5rem; }}
    h2 {{ margin-top: 0; color: #666; font-weight: normal; font-size: 1.2rem; }}
    audio {{ width:100%; margin:1rem 0; }}
    .word {{ padding:0 2px; transition:background 0.2s; cursor: pointer; }}
    .highlight {{ background-color: #ffc107; color: #000; border-radius:3px; }}
    footer {{ margin-top: 2rem; text-align: center; font-size: 0.9rem; color: #888; }}
    footer a {{ color: #555; text-decoration: none; }}
    footer a:hover {{ text-decoration: underline; }}
  </style>
</head>
<body>
  <h1>{title}</h1>
  {subtitle_html}
  <audio id="player" controls src="{audio_filename}"></audio>
  <p id="transcript">{final_html_body}</p>
  <script>
    const audio = document.getElementById("player");
    const words = document.querySelectorAll(".word");

    // Créer un cache des timings pour éviter le parsing répétitif
    const wordTimings = Array.from(words).map(w => ({{
      element: w,
      start: parseFloat(w.dataset.start),
      end: parseFloat(w.dataset.end),
      wordId: w.dataset.wordId || Math.random() // fallback pour compatibilité
    }}));

    audio.addEventListener("timeupdate", () => {{
      const currentTime = audio.currentTime;

      // Enlever tous les highlights actuels
      wordTimings.forEach(word => word.element.classList.remove("highlight"));

      // Trouver le mot actuellement lu (le plus récent qui a commencé)
      let currentWord = null;
      let latestStart = -1;

      for (const word of wordTimings) {{
        if (currentTime >= word.start && currentTime < word.end) {{
          if (word.start > latestStart) {{
            currentWord = word;
            latestStart = word.start;
          }}
        }}
      }}

      // Surligner uniquement le mot courant
      if (currentWord) {{
        currentWord.element.classList.add("highlight");
      }}
    }});

    // Permettre de cliquer sur les mots pour naviguer dans l'audio
    words.forEach(word => {{
      word.addEventListener("click", () => {{
        const start = parseFloat(word.dataset.start);
        if (!isNaN(start)) {{
          audio.currentTime = start;
          audio.play();
        }}
      }});
    }});
  </script>
  <footer>
    <p>Generated by <a href="https://laurentftech.github.io/Podcast_generator" target="_blank">Podcast Generator</a></p>
  </footer>
</body>
</html>